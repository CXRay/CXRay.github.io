<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>


    <meta name="description" content="Live For The Dream!" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description" content="Live For The Dream!">
<meta property="og:type" content="website">
<meta property="og:title" content="Ray">
<meta property="og:url" content="http://cxray.github.io/page/4/index.html">
<meta property="og:site_name" content="Ray">
<meta property="og:description" content="Live For The Dream!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ray">
<meta name="twitter:description" content="Live For The Dream!">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> Ray </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Ray</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">subtitle</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/12/2015-09-12-类型检查和向下转型is&as类型转换Any&AnyObject-Swift/" itemprop="url">
                  类型检查和向下转型is&as类型转换Any&AnyObject
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-12T00:00:00+08:00" content="2015-09-12">
              2015-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>###转载自<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/19_Type_Casting.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/swift/chapter2/19_Type_Casting.html</a></p>
<p>###检查类型(Checking Type)</p>
<p>用类型检查操作符( is )来检查一个实例是否属于特定子类型。若实例属于那个子类型,类型检查操作符返回true ,否则返回 false 。</p>
<p>下面的例子定义了两个变量, movieCount 和 songCount ,用来计算数组 library 中 Movie 和 Song 类 型的实例数量。</p>
<pre><code>class MediaItem { 
    var name: String 
    init(name: String) {
    self.name = name 
    }
}

class Movie: MediaItem {
    var director: String
    init(name: String, director: String) {
        self.director = director
        super.init(name: name) 
    }
}

class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name) 
        }
}

let library = [
    Movie(name: &quot;Casablanca&quot;, director: &quot;Michael Curtiz&quot;), 
    Song(name: &quot;Blue Suede Shoes&quot;, artist: &quot;Elvis Presley&quot;),
    Movie(name: &quot;Citizen Kane&quot;, director: &quot;Orson Welles&quot;), 
    Song(name: &quot;The One And Only&quot;, artist: &quot;Chesney Hawkes&quot;),
    Song(name: &quot;Never Gonna Give You Up&quot;, artist: &quot;Rick Astley&quot;)
]
// the type of &quot;library&quot; is inferred to be [MediaItem]

var movieCount = 0 var songCount = 0
for item in library { 
    if item is Movie {
        ++movieCount
    } else if item is Song {
        ++songCount
    }
}
print(&quot;Media library contains \(movieCount) movies and \(songCount) songs&quot;) 
// prints &quot;Media library contains 2 movies and 3 songs&quot;
</code></pre><p>示例迭代了数组 library 中的所有项。每一次, for - in 循环设置 item 为数组中的下一个 MediaItem 。</p>
<p>若当前 MediaItem 是一个 Movie 类型的实例, item is Movie 返回 true ,相反返回 false 。同样的, ite m is Song 检查item是否为 Song 类型的实例。在循环结束后, movieCount 和 songCount 的值就是被找 到属于各自的类型的实例数量。</p>
<p>###向下转型(Downcasting)</p>
<p>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时,你可以尝试向下转到它的子类型,用类型转换操作符( as? 或 as! )</p>
<p>因为向下转型可能会失败,类型转型操作符带有两种不同形式。条件形式(conditional form) as? 返回一个 你试图向下转成的类型的可选值(optional value)。强制形式 as! 把试图向下转型和强制解包(force-unwr aps)结果作为一个混合动作。</p>
<p>当你不确定向下转型可以成功时,用类型转换的条件形式( as? )。条件形式的类型转换总是返回一个可选值(op tional value),并且若下转是不可能的,可选值将是 nil 。这使你能够检查向下转型是否成功。</p>
<p>只有你可以确定向下转型一定会成功时,才使用强制形式( as! )。当你试图向下转型为一个不正确的类型时,强 制形式的类型转换会触发一个运行时错误。</p>
<p>下面的例子,迭代了 library 里的每一个 MediaItem ,并打印出适当的描述。要这样做, item 需要真正作为 Movie 或 Song 的类型来使用,不仅仅是作为 MediaItem 。为了能够在描述中使用 Movie 或 Song 的 director 或 artist 属性,这是必要的。</p>
<p>在这个示例中,数组中的每一个 item 可能是 Movie 或 Song 。事前你不知道每个 item 的真实类型,所以 这里使用条件形式的类型转换( as? )去检查循环里的每次下转。</p>
<pre><code>for item in library {
    if let movie = item as? Movie {
        print(&quot;Movie: &apos;\(movie.name)&apos;, dir. \(movie.director)&quot;) 
    } else if let song = item as? Song {
        print(&quot;Song: &apos;\(song.name)&apos;, by \(song.artist)&quot;) }
    }
// Movie: &apos;Casablanca&apos;, dir. Michael Curtiz
// Song: &apos;Blue Suede Shoes&apos;, by Elvis Presley
// Movie: &apos;Citizen Kane&apos;, dir. Orson Welles
// Song: &apos;The One And Only&apos;, by Chesney Hawkes 
// Song: &apos;Never Gonna Give You Up&apos;, by Rick Astley
</code></pre><p>示例首先试图将 ￼item 下转为 Movie 。因为item 是一个MediaItem类型的实例，它可能是一个Movie;同样,它也可能是一个 ￼Song ,或者仅仅是基类MediaItem 。因为不确定，as？形式在试图下转时将返回一个可选值。item as？ Movie 的返回值是Movie？或“可选Movie”类型。</p>
<p>当向下转型为 Movie￼ 应用在两个 Song 实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定(optional binding)来检查可选Movie真的包含一个值(这个是为了判断下转是否成功。)可选绑定是这样写的 “if let movie = item as? Movie”,可以这样解读：</p>
<p>“尝试将item 转为 Movie 类型。若成功，设置一个新的临时常量movie来储存返回的可选Movie”</p>
<p>若向下转型成功，然后movie 的属性将用于打印一个Movie实例的描述,包括它的导演的名字director。相近的原理被用来检测Song实例,当 Song￼ 被找到时则打印它的描述(包含 artist￼ 的名字)。    </p>
<p>注意:<br> 转换没有真的改变实例或它的值。潜在的根本的实例保持不变;只是简单地把它作为它被转换成的类来使用。</p>
<p>###Any和AnyObject￼的类型转换</p>
<p>Swift为不确定类型提供了两种特殊类型别名:</p>
<ul>
<li>可以代表任何class类型的实例。</li>
<li>可以表示任何类型,包括方法类型(function types)。</li>
</ul>
<p>注意:</p>
<p>只有当你明确的需要它的行为和功能时才使用 和 ￼ 。在你的代码里使用你期望的明确的类型总 是更好的。</p>
<p>###AnyObject类型<br>当在工作中使用 Cocoa APIs,我们一般会接收一个 [AnyObject]￼ 类型的数组,或者说“一个任何对象类型的数组”。这是因为 Objective-C 没有明确的类型化数组。但是,你常常可以从 API 提供的信息中清晰地确定数组中对象的类型。</p>
<p>在这些情况下,你可以使用强制形式的类型转换( ￼as )来下转在数组中的每一项到比 AnyObject￼ 更明确的类型,不需要可选解析(optional unwrapping)。</p>
<p>下面的示例定义了一个[AnyObject]类型的数组并填入三个Movie类型的实例:</p>
<pre><code>let someObjects: [AnyObject] = [
    Movie(name: &quot;2001: A Space Odyssey&quot;, director: &quot;Stanley Kubrick&quot;), 
    Movie(name: &quot;Moon&quot;, director: &quot;Duncan Jones&quot;),
    Movie(name: &quot;Alien&quot;, director: &quot;Ridley Scott&quot;)
]
</code></pre><p>因为知道这个数组只包含 Movie 实例,你可以直接用( as! )下转并解包到不可选的 Movie 类型:</p>
<pre><code>for object in someObjects {
    let movie = object as! Movie
    print(&quot;Movie: &apos;\(movie.name)&apos;, dir. \(movie.director)&quot;)
}
// Movie: &apos;2001: A Space Odyssey&apos;, dir. Stanley Kubrick 
// Movie: &apos;Moon&apos;, dir. Duncan Jones
// Movie: &apos;Alien&apos;, dir. Ridley Scott
</code></pre><p>为了变为一个更短的形式,下转 someObjects 数组为 [Movie] 类型来代替下转数组中每一项的方式。</p>
<pre><code>for movie in someObjects as! [Movie] {
    print(&quot;Movie: &apos;\(movie.name)&apos;, dir. \(movie.director)&quot;)
}
// Movie: &apos;2001: A Space Odyssey&apos;, dir. Stanley Kubrick 
// Movie: &apos;Moon&apos;, dir. Duncan Jones
// Movie: &apos;Alien&apos;, dir. Ridley Scott
</code></pre><p>###Any 类型</p>
<p>这里有个示例,使用 Any 类型来和混合的不同类型一起工作,包括方法类型和非 class 类型。它创建了一个 可以存储 Any 类型的数组 things 。</p>
<pre><code>var things = [Any]()
things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append(&quot;hello&quot;)
things.append((3.0, 5.0))
things.append(Movie(name: &quot;Ghostbusters&quot;, director: &quot;Ivan Reitman&quot;)) 
things.append({ (name: String) -&gt; String in &quot;Hello, \(name)&quot; })
</code></pre><p>things 数组包含两个 Int 值,2个 Double 值,1个 String 值,一个元组 (Double, Double) ,电影“Gho stbusters”,和一个获取 String 值并返回另一个 String 值的闭包表达式。</p>
<p>你可以在 switch 表达式的cases中使用 is 和 as 操作符来发觉只知道是 Any 或 AnyObject 的常量或变 量的类型。下面的示例迭代 things 数组中的每一项的并用 switch 语句查找每一项的类型。这几种 switch 语 句的情形绑定它们匹配的值到一个规定类型的常量,让它们的值可以被打印:</p>
<pre><code>for thing in things { 
    switch thing { 
    case 0 as Int:
        print(&quot;zero as an Int&quot;) 
    case 0 as Double:
        print(&quot;zero as a Double&quot;)
    case let someInt as Int:
        print(&quot;an integer value of \(someInt)&quot;)
    case let someDouble as Double where someDouble &gt; 0: 
        print(&quot;a positive double value of \(someDouble)&quot;)
    case is Double:
        print(&quot;some other double value that I don&apos;t want to print&quot;)
    case let someString as String:
        print(&quot;a string value of \&quot;\(someString)\&quot;&quot;)
    case let (x, y) as (Double, Double): print(&quot;an (x, y) point at \(x), \(y)&quot;)
    case let movie as Movie:
        print(&quot;a movie called &apos;\(movie.name)&apos;, dir. \(movie.director)&quot;)
    case let stringConverter as String -&gt; String:             print(stringConverter(&quot;Michael&quot;))
    default:
        print(&quot;something else&quot;)
    } 
}
// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of &quot;hello&quot;
// an (x, y) point at 3.0, 5.0
// a movie called &apos;Ghostbusters&apos;, dir. Ivan Reitman // Hello, Michael
</code></pre><p>注意:</p>
<p>在一个switch语句的case中使用强制形式的类型转换操作符(as, 而不是 as?)来检查和转换到一个明确的类 型。在 switch case 语句的内容中这种检查总是安全的。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/11/2015-09-11-自动引用计数-Swift/" itemprop="url">
                  自动引用计数(Automatic Reference Counting)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-11T00:00:00+08:00" content="2015-09-11">
              2015-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>##转载自<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/16_Automatic_Reference_Counting.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/swift/chapter2/16_Automatic_Reference_Counting.html</a></p>
<p>##这一部分难以理解</p>
<p>Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 的内存管理机制会一直起着作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。</p>
<p>然而，在少数情况下，ARC 为了能帮助你管理内存，需要更多的关于你的代码之间关系的信息。本章描述了这些情况，并且为你示范怎样启用 ARC 来管理你的应用程序的内存。</p>
<p>注意:</p>
<p>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
<p>###自动引用计数的工作机制</p>
<p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。</p>
<p>此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>
<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。</p>
<p>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>
<p>为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢的保持住，只要强引用还在，实例是不允许被销毁的。</p>
<p>###自动引用计数实践</p>
<p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的Person类开始，并定义了一个叫name的常量属性：</p>
<pre><code>class Person {
    let name: String
    init(name: String) {
        self.name = name
        print(&quot;\(name) is being initialized&quot;)
    }
    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }
}
</code></pre><p>Person类有一个构造函数，此构造函数为实例的name属性赋值，并打印一条消息以表明初始化过程生效。Person类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。</p>
<p>接下来的代码片段定义了三个类型为Person?的变量，用来按照代码片段中的顺序，为新的Person实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为nil，目前还不会引用到Person类的实例。</p>
<pre><code>var reference1: Person?
var reference2: Person?
var reference3: Person?
</code></pre><p>现在你可以创建Person类的新实例，并且将它赋值给三个变量中的一个：</p>
<pre><code>reference1 = Person(name: &quot;John Appleseed&quot;)
// prints &quot;John Appleseed is being initialized”
</code></pre><p>应当注意到当你调用Person类的构造函数的时候，”John Appleseed is being initialized”会被打印出来。由此可以确定构造函数被执行。</p>
<p>由于Person类的新实例被赋值给了reference1变量，所以reference1到Person类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证Person实例被保持在内存中不被销毁。</p>
<p>如果你将同一个Person实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>
<pre><code>reference2 = reference1
reference3 = reference1
</code></pre><p>现在这一个Person实例已经有三个强引用了。</p>
<p>如果你通过给其中两个变量赋值nil的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，Person实例不会被销毁：</p>
<pre><code>reference1 = nil
reference2 = nil
</code></pre><p>在你清楚地表明不再使用这个Person实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它。</p>
<pre><code>reference3 = nil
// prints &quot;John Appleseed is being deinitialized&quot;
</code></pre><p>###类实例之间的循环强引用</p>
<p>在上面的例子中，ARC 会跟踪你所新创建的Person实例的引用数量，并且会在Person实例不再被需要时销毁它。</p>
<p>然而，我们可能会写出一个类实例的强引用数永远不能变成0的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。</p>
<p>你可以通过定义类之间的关系为弱引用或无主引用，以替代强引用，从而解决循环强引用的问题。具体的过程在解决类实例之间的循环强引用中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。</p>
<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：Person和Apartment，用来建模公寓和它其中的居民:</p>
<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}


class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    var tenant: Person?
    deinit { print(&quot;Apartment #\(number) is being deinitialized&quot;) }
}
</code></pre><p>每一个Person实例有一个类型为String，名字为name的属性，并有一个可选的初始化为nil的apartment属性。apartment属性是可选的，因为一个人并不总是拥有公寓。</p>
<p>类似的，每个Apartment实例有一个叫number，类型为Int的属性，并有一个可选的初始化为nil的tenant属性。tenant属性是可选的，因为一栋公寓并不总是有居民。</p>
<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓Person和Apartment的实例是否像预期的那样被销毁。</p>
<p>接下来的代码片段定义了两个可选类型的变量john和number73，并分别被设定为下面的Apartment和Person的实例。这两个变量都被初始化为nil，这正是可选的优点：</p>
<pre><code>var john: Person?
var number73: Apartment?
</code></pre><p>现在你可以创建特定的Person和Apartment实例并将赋值给john和number73变量：</p>
<pre><code>john = Person(name: &quot;John Appleseed&quot;)
number73 = Apartment(number: 73)
</code></pre><p>在两个实例被创建和赋值后，下图表现了强引用的关系。变量john现在有一个指向Person实例的强引用，而变量number73有一个指向Apartment实例的强引用：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/1.png" alt="1"></p>
<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量john和number73中的实例，这样实例的属性才能被赋值：</p>
<pre><code>john!.apartment = number73
number73!.tenant = john
</code></pre><p>在将两个实例联系在一起之后，强引用的关系如图所示：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/2.png" alt="2"></p>
<p>不幸的是，这两个实例关联后会产生一个循环强引用。Person实例现在有了一个指向Apartment实例的强引用，而Apartment实例也有了一个指向Person实例的强引用。因此，当你断开john和number73变量所持有的强引用时，引用计数并不会降为 0，实例也不会被 ARC 销毁：</p>
<pre><code>john = nil
number73 = nil
</code></pre><p>注意，当你把这两个变量设为nil时，没有任何一个析构函数被调用。循环强引用会一直阻止Person和Apartment类实例的销毁，这就在你的应用程序中造成了内存泄漏。</p>
<p>在你将john和number73赋值为nil后，强引用关系如下图：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/3.png" alt="3"></p>
<p>Person和Apartment实例之间的强引用关系保留了下来并且不会被断开。</p>
<p>###解决实例之间的循环强引用</p>
<p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。</p>
<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>
<p>对于生命周期中会变为nil的实例使用弱引用。相反地，对于初始化赋值后再也不会被赋值为nil的实例，使用无主引用。</p>
<p>###弱引用</p>
<p>弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上weak关键字表明这是一个弱引用。</p>
<p>在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以避免循环强引用。如果引用总是有值，则可以使用无主引用，在无主引用中有描述。在上面Apartment的例子中，一个公寓的生命周期中，有时是没有“居民”的，因此适合使用弱引用来解决循环强引用。</p>
<p>注意:<br>弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。<br>因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。在 Swift 中，推荐使用可选类型描述可能没有值的类型。</p>
<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。</p>
<p>下面的例子跟上面Person和Apartment的例子一致，但是有一个重要的区别。这一次，Apartment的tenant属性被声明为弱引用：</p>
<pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class Apartment {
    let number: Int
    init(number: Int) { self.number = number }
    weak var tenant: Person?
    deinit { print(&quot;Apartment #\(number) is being deinitialized&quot;) }
}
</code></pre><p>然后跟之前一样，建立两个变量（john和number73）之间的强引用，并关联两个实例：</p>
<pre><code>var john: Person?
var number73: Apartment?

john = Person(name: &quot;John Appleseed&quot;)
number73 = Apartment(number: 73)

john!.apartment = number73
number73!.tenant = john
</code></pre><p>现在，两个关联在一起的实例的引用关系如下图所示：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/4.png" alt="4"></p>
<p>Person实例依然保持对Apartment实例的强引用，但是Apartment实例只是对Person实例的弱引用。这意味着当你断开john变量所保持的强引用时，再也没有指向Person实例的强引用了：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/5.png" alt="5"></p>
<p>由于再也没有指向Person实例的强引用，该实例会被销毁：</p>
<pre><code>john = nil
// prints &quot;John Appleseed is being deinitialized&quot;
</code></pre><p>唯一剩下的指向Apartment实例的强引用来自于变量number73。如果你断开这个强引用，再也没有指向Apartment实例的强引用了：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/6.png" alt="6"></p>
<p>由于再也没有指向Apartment实例的强引用，该实例也会被销毁：</p>
<pre><code>number73 = nil
// prints &quot;Apartment #73 is being deinitialized&quot;
</code></pre><p>上面的两段代码展示了变量john和number73在被赋值为nil后，Person实例和Apartment实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>
<p>###无主引用</p>
<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。</p>
<p>由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为nil，因为非可选类型的变量不允许被赋值为nil。</p>
<p>注意:</p>
<p>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。</p>
<p>还需要注意的是如果你试图访问实例已经被销毁的无主引用，Swift 确保程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。</p>
<p>下面的例子定义了两个类，Customer和CreditCard，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。</p>
<p>Customer和CreditCard之间的关系与前面弱引用例子中Apartment和Person的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，Customer类有一个可选类型的card属性，但是CreditCard类有一个非可选类型的customer属性。</p>
<p>此外，只能通过将一个number值和customer实例传递给CreditCard构造函数的方式来创建CreditCard实例。这样可以确保当创建CreditCard实例时总是有一个customer实例与之关联。</p>
<p>由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用：</p>
<pre><code>class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print(&quot;\(name) is being deinitialized&quot;) }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print(&quot;Card #\(number) is being deinitialized&quot;) }
}
</code></pre><p>注意: </p>
<p>CreditCard类的number属性被定义为UInt64类型而不是Int类型，以确保number属性的存储量在32位和64位系统上都能足够容纳16位的卡号。</p>
<p>下面的代码片段定义了一个叫john的可选类型Customer变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为nil。</p>
<pre><code>var john: Customer?
</code></pre><p>现在你可以创建Customer类的实例，用它初始化CreditCard实例，并将新创建的CreditCard实例赋值为客户的card属性。</p>
<pre><code>john = Customer(name: &quot;John Appleseed&quot;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</code></pre><p>在你关联两个实例后，它们的引用关系如下图所示：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/7.png" alt="7"></p>
<p>Customer实例持有对CreditCard实例的强引用，而CreditCard实例持有对Customer实例的无主引用。</p>
<p>由于customer的无主引用，当你断开john变量持有的强引用时，再也没有指向Customer实例的强引用了：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/8.png" alt="8"></p>
<p>由于再也没有指向Customer实例的强引用，该实例被销毁了。其后，再也没有指向CreditCard实例的强引用，该实例也随之被销毁了：</p>
<pre><code>john = nil
// prints &quot;John Appleseed is being deinitialized&quot;
// prints &quot;Card #1234567890123456 is being deinitialized&quot;
</code></pre><p>最后的代码展示了在john变量被设为nil后Customer实例和CreditCard实例的构造函数都打印出了“销毁”的信息。</p>
<p>###无主引用以及隐式解析可选属性</p>
<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>
<p>Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>
<p>Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>
<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>
<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>
<p>下面的例子定义了两个类，Country和City，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，Country类拥有一个capitalCity属性，而City类有一个country属性：</p>
<pre><code>class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}

class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</code></pre><p>为了建立两个类的依赖关系，City的构造函数有一个Country实例的参数，并且将实例保存为country属性。</p>
<p>Country的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化完后，Country的构造函数才能把self传给City的构造函数。（在两段式构造过程中有具体描述）</p>
<p>为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这表示像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它。（在隐式解析可选类型中有描述）</p>
<p>由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这代表一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数。</p>
<p>以上的意义在于你可以通过一条语句同时创建Country和City的实例，而不产生循环强引用，并且capitalCity的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>
<pre><code>var country = Country(name: &quot;Canada&quot;, capitalName: &quot;Ottawa&quot;)
print(&quot;\(country.name)&apos;s capital city is called \(country.capitalCity.name)&quot;)
// prints &quot;Canada&apos;s capital city is called Ottawa&quot;
</code></pre><p>在上面的例子中，使用隐式解析可选值的意义在于满足了两个类构造函数的需求。capitalCity属性在初始化完成后，能像非可选值一样使用和存取同时还避免了循环强引用。</p>
<p>###闭包引起的循环强引用<br>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。</p>
<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod。这两种情况都导致了闭包 “捕获” self，从而产生了循环强引用。</p>
<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你也把一个引用赋值给了这个闭包。实质上，这跟之前的问题是一样的－两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>
<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closuer capture list）。同样的，在学习如何用闭包捕获列表破坏循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。</p>
<p>下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 中的一个单独的元素：</p>
<pre><code>class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: Void -&gt; String = {
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }

    }
</code></pre><p>HTMLElement类定义了一个name属性来表示这个元素的名称，例如代表段落的”p”，或者代表换行的”br”。HTMLElement还定义了一个可选属性text，用来设置和展现 HTML 元素的文本。</p>
<p>除了上面的两个属性，HTMLElement还定义了一个lazy属性asHTML。这个属性引用了一个将name和text组合成 HTML 字符串片段的闭包。该属性是Void -&gt; String类型，或者可以理解为“一个没有参数，返回String的函数”。</p>
<p>默认情况下，闭包赋值给了asHTML属性，这个闭包返回一个代表 HTML 标签的字符串。如果text值存在，该标签就包含可选值text；如果text不存在，该标签就不包含文本。对于段落元素，根据text是”some text”还是nil，闭包会返回”</p><p>some text</p>“或者”<p>“。</p>
<p>可以像实例方法那样去命名、使用asHTML属性。然而，由于asHTML是闭包而不是实例方法，如果你想改变特定元素的 HTML 处理的话，可以用自定义的闭包来取代默认值。</p>
<p>注意:</p>
<p>asHTML声明为lazy属性，因为只有当元素确实需要处理为HTML输出的字符串时，才需要使用asHTML。也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属性。</p>
<p>HTMLElement类只提供一个构造函数，通过name和text（如果有的话）参数来初始化一个元素。该类也定义了一个析构函数，当HTMLElement实例被销毁时，打印一条消息。</p>
<p>下面的代码展示了如何用HTMLElement类创建实例并打印消息。</p>
<pre><code>var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)
print(paragraph!.asHTML())
// prints&quot;hello, world&quot;
</code></pre><p>注意:</p>
<p>上面的paragraph变量定义为可选HTMLElement，因此我们可以赋值nil给它来演示循环强引用。</p>
<p>不幸的是，上面写的HTMLElement类产生了类实例和asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/9.png" alt="9"></p>
<p>实例的asHTML属性持有闭包的强引用。但是，闭包在其闭包体内使用了self（引用了self.name和self.text），因此闭包捕获了self，这意味着闭包又反过来持有了HTMLElement实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包捕获值的信息，请参考值捕获）。</p>
<p>注意:</p>
<p>虽然闭包多次使用了self，它只捕获HTMLElement实例的一个强引用。</p>
<p>如果设置paragraph变量为nil，打破它持有的HTMLElement实例的强引用，HTMLElement实例和它的闭包都不会被销毁，也是因为循环强引用：</p>
<pre><code>paragraph = nil
</code></pre><p>注意HTMLElementdeinitializer中的消息并没有被打印，证明了HTMLElement实例并没有被销毁。</p>
<p>###解决闭包引起的循环强引用</p>
<p>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>
<p>注意:</p>
<p>Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod（而不只是someProperty或someMethod）。这提醒你可能会一不小心就捕获了self。</p>
<p>###定义捕获列表</p>
<p>捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。</p>
<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面：</p>
<pre><code>lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int,     stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre><p>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方：</p>
<pre><code>lazy var someClosure: Void -&gt; String = {
    [unowned self, weak delegate = self.delegate!] in
    // closure body goes here
}
</code></pre><p>###弱引用和无主引用</p>
<p>在闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用。</p>
<p>相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。</p>
<p>注意:</p>
<p>如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。</p>
<p>前面的HTMLElement例子中，无主引用是正确的解决循环强引用的方法。这样编写HTMLElement类来避免循环强引用：</p>
<pre><code>class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: Void -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
        } else {
            return &quot;&lt;\(self.name) /&gt;&quot;
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        print(&quot;\(name) is being deinitialized&quot;)
    }

}
</code></pre><p>上面的HTMLElement实现和之前的实现一致，除了在asHTML闭包中多了一个捕获列表。这里，捕获列表是[unowned self]，表示“用无主引用而不是强引用来捕获self”。</p>
<p>和之前一样，我们可以创建并打印HTMLElement实例：</p>
<pre><code>var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)
print(paragraph!.asHTML())
// prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;
</code></pre><p>使用捕获列表后引用关系如下图所示：</p>
<p><img src="http://cxray.github.io/public/images/Automatic Reference Counting/10.png" alt="10"></p>
<p>这一次，闭包以无主引用的形式捕获self，并不会持有HTMLElement实例的强引用。如果将paragraph赋值为nil，HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息。</p>
<pre><code>paragraph = nil
// prints &quot;p is being deinitialized&quot;
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/10/2015-09-10-iOS学习资料整理-iOS/" itemprop="url">
                  iOS学习资料整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-10T00:00:00+08:00" content="2015-09-10">
              2015-09-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>转载自<a href="https://github.com/Aufree/trip-to-iOS" target="_blank" rel="external">https://github.com/Aufree/trip-to-iOS</a></p>
<p><a href="http://www.cocoachina.com/ios/20150826/13151.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150826/13151.html</a></p>
<p>感谢作者</p>
</blockquote>
<p>这份学习资料是为 iOS 初学者所准备的, 旨在帮助 iOS 初学者们快速找到适合自己的学习资料, 节省他们搜索资料的时间, 使他们更好的规划好自己的 iOS 学习路线, 更快的入门, 更准确的定位的目前所处的位置.</p>
<p>该文档会持续更新, 同时也欢迎更多具有丰富经验的 iOS 开发者将自己的常用的一些工具, 学习资料, 学习心得等分享上来, 我将定期筛选合并, 文档尚有一些不完善之处, 也请不吝指出, 感谢您对 iOS 所做的贡献, 让我们一起把国内的 iOS 做得更好,  谢谢.</p>
<p><strong>如果您有任何意见或建议也可以通过<a href="mailto:freedomlijinfa@gmail.com" target="_blank" rel="external">邮件</a>或<a href="http://weibo.com/jinfali" target="_blank" rel="external">微博</a>联系我</strong></p>
<h2 id="u89C6_u9891_u6559_u7A0B_28_u82F1_u6587_29"><a href="#u89C6_u9891_u6559_u7A0B_28_u82F1_u6587_29" class="headerlink" title="视频教程(英文)"></a>视频教程(英文)</h2><table>
<thead>
<tr>
<th>视频</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550" target="_blank" rel="external">Developing iOS 7 Apps for iPhone and iPad</a></td>
<td>斯坦福开放教程之一, 课程主要讲解了一些 iOS 开发工具和 API 以及 iOS SDK 的使用, 属于 iOS 基础视频</td>
</tr>
<tr>
<td><a href="https://itunes.apple.com/itunes-u/ipad-iphone-application-development/id473757255" target="_blank" rel="external">iPad and iPhone Application Development</a></td>
<td>该课程的讲师 Paul Hegarty 是斯坦福大学软件工程学教授, 视频内容讲解得深入, 权威, 深受好评</td>
</tr>
<tr>
<td><a href="https://itunes.apple.com/itunes-u/advanced-iphone-development/id407243028" target="_blank" rel="external">Advanced iPhone Development - Fall 2010</a></td>
<td>iOS 开发的进阶课程, 开始涉及到 Core Animation, Core Data, OpenGL 等框架的应用</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/devcenter/ios/index.action" target="_blank" rel="external">iOS Dev Center</a></td>
<td>苹果官方提供的 iOS 学习视频</td>
</tr>
<tr>
<td><a href="http://www.lynda.com/search?q=ios" target="_blank" rel="external">Lynda</a></td>
<td>Lynda 上面 iOS 和 Objective-C 的学习资料比较多, 从初级到高级的都有, 覆盖面比较广, 无论 iOS 走到哪个层次, 都可以在上面挑到适合自己的课程</td>
</tr>
<tr>
<td><a href="https://www.codeschool.com/paths/ios" target="_blank" rel="external">Code School</a></td>
<td>CodeSchool 上面的 iOS 不多, 不过质量都不错, 一些课程也挺有趣的</td>
</tr>
<tr>
<td><a href="https://www.udemy.com/topic/learn-objective-c" target="_blank" rel="external">Udemy</a></td>
<td>Udemy 帮助初学者规划了视频学习路线, 从新手到高级分的比较详细</td>
</tr>
<tr>
<td><a href="https://itunes.apple.com/us/course/developing-ios-8-apps-swift/id961180099" target="_blank" rel="external">Developing iOS 8 Apps with Swift</a></td>
<td>斯坦福白胡子老爷爷最新的 iOS8 和 Swift 课程, 现在 <a href="https://github.com/x140yu/Developing_iOS_8_Apps_With_Swift" target="_blank" rel="external">GitHub</a> 上面也有人在翻译</td>
</tr>
</tbody>
</table>
<h2 id="u89C6_u9891_u6559_u7A0B_28_u4E2D_u6587_29"><a href="#u89C6_u9891_u6559_u7A0B_28_u4E2D_u6587_29" class="headerlink" title="视频教程(中文)"></a>视频教程(中文)</h2><table>
<thead>
<tr>
<th>视频</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://v.163.com/special/opencourse/ios7.html" target="_blank" rel="external">iOS 7 应用开发</a></td>
<td>斯坦福白胡子老爷爷的系列视频, 所有视频皆完成翻译, 视频较新, 翻译质量也很高</td>
</tr>
<tr>
<td><a href="http://v.163.com/special/opencourse/iphonekaifa.html" target="_blank" rel="external">iPhone 开发教程 2010 年冬</a></td>
<td>全部视频翻译完毕, 较为深入的讲解 iPhone 开发, 视频适合给有一定 Objective-C 基础的人观看</td>
</tr>
<tr>
<td><a href="http://www.imooc.com/learn/173" target="_blank" rel="external">使用 Swift 开发 iOS8 App 实战</a></td>
<td>慕课网的视频, 主要讲 Swift 的一些基本使用, 并在讲解的过程中做了几个小 APP, 最后还讲了 Sketch 制作分享按钮</td>
</tr>
<tr>
<td><a href="http://www.imooc.com/learn/218" target="_blank" rel="external">征战 Objective-C</a></td>
<td>视频还未完结, 讲了一些 C 和 Objective-C 的基本语法, 适合零基础的人观看</td>
</tr>
<tr>
<td><a href="https://github.com/x140yu/Developing_iOS_8_Apps_With_Swift" target="_blank" rel="external">Developing iOS 8 Apps with Swift</a></td>
<td>GitHub 上正在翻译的斯坦福最新的 iOS8 课程, 目前正在翻译, 未完结</td>
</tr>
</tbody>
</table>
<h2 id="u4E66_u7C4D"><a href="#u4E66_u7C4D" class="headerlink" title="书籍"></a>书籍</h2><table>
<thead>
<tr>
<th>书籍名称</th>
<th>推荐理由</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.amazon.com/dp/032194206X/ref=cm_sw_r_tw_dp_fWrPub0BGRHJ3" target="_blank" rel="external">Objective-C Programming</a></td>
<td>内容不多, 却都是精华, 有了一点 C 语言基础可以快速阅读此书, 大概一天时间就可以看完, 看完后对 iOS 开发能够有个基本的印象, 该书的<a href="http://forums.bignerdranch.com" target="_blank" rel="external">官方论坛</a>有各个章节习题的解答.</td>
</tr>
<tr>
<td><a href="http://book.douban.com/subject/24538384" target="_blank" rel="external">iOS Programming</a></td>
<td>这本书在 Quora 上被评为 iOS 入门最佳书籍,  具体评价可见豆瓣下方该书籍的评论</td>
</tr>
<tr>
<td><a href="http://book.douban.com/subject/3688896" target="_blank" rel="external">Cocoa Design Patterns</a></td>
<td>适合打算深入了解 Cocoa 的人看</td>
</tr>
<tr>
<td><a href="http://cocoadevcentral.com/d/learn_objectivec" target="_blank" rel="external">Learn Objective-C</a></td>
<td>短小精练, 适合有编程基础的人在半小时内对 Objective-C 有个一定了解</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" target="_blank" rel="external">Programming with Objective-C</a></td>
<td>看完 Learn Objective-C 可以接着看这个官方对 Objective-C 更为深入的介绍</td>
</tr>
<tr>
<td><a href="http://www.amazon.cn/dp/B00COG40Y0/ref=cm_sw_r_qz_2_dp_l2OPub0N45R0Q" target="_blank" rel="external">Objective-C 基础教程</a></td>
<td>该书作者 Scott Knaster 是 Mac 开发界的传奇人物, 目前在 Google 出过多数书籍都广受许多程序员好评, 此书适合从初级跳到中级的 iOS 开发者阅读</td>
</tr>
<tr>
<td><a href="http://www.amazon.cn/dp/B00R43XG9S/ref=cm_sw_r_qz_pi_T2A_jdp_fCPPub0VBF67T" target="_blank" rel="external">iOS 开发进阶</a></td>
<td>该书作者唐巧是国内 iOS 开发界的名人, 曾参与多个知名软件的开发, 目前该书尚在预售中, 书本内容由浅入深, 将读者一步一步引入到 iOS 中去, 同样适合初级跳到中级的 iOS 开发者阅读</td>
</tr>
<tr>
<td><a href="http://www.amazon.com/Programming-Objective-C-Edition-Developers-Library/dp/0321967607" target="_blank" rel="external">Programming in Objective-C</a></td>
<td>这本书在亚马逊上面深受欢迎, 有关 Objective-C 的东西讲得非常详细</td>
</tr>
<tr>
<td><a href="http://www.amazon.cn/dp/B00JPVNFKM/ref=cm_sw_r_qz_4_dp_tdPPub14X59PV" target="_blank" rel="external">iOS 测试指南</a></td>
<td>该书作者是豆瓣的员工, 书中写的多数内容都是作者在平时的工作实践当中提炼出来的测试经验, 重点讲述了各个测试阶段的具体实践方法, 并且通过持续集成串联了各个测试阶段的活动。</td>
</tr>
<tr>
<td><a href="http://book.douban.com/subject/6920082" target="_blank" rel="external">Objective-C 编程之道</a></td>
<td>解析 iOS 的开山之作, 详细介绍了 MVC 在 Cocoa Touch 上的运作过程, 该书适用于 iOS 中级开发者阅读</td>
</tr>
<tr>
<td><a href="http://www.amazon.cn/dp/B00DE60G3S/ref=cm_sw_r_qz_2_dp_hdPPub11MFE6G" target="_blank" rel="external">Objective-C 高级编程</a></td>
<td>本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码,  告诉你一些苹果公司官方文档中不会出现的知识, 适合中级以上 iOS 开发人员阅读</td>
</tr>
<tr>
<td><a href="http://www.amazon.cn/dp/B00IDSGY06/ref=cm_sw_r_qz_2_dp_A2OPub0CH96YH" target="_blank" rel="external">Effective Objective C 2.0</a></td>
<td>书里写了编写高质量 iOS 与 OS X 代码的 52 个有效方法, 适合 iOS 开发的进阶使用</td>
</tr>
<tr>
<td><a href="http://www.amazon.com/dp/0990402053/ref=cm_sw_r_tw_dp_louPub127Q1YP" target="_blank" rel="external">Swift Fundamentals</a></td>
<td>估计将来这本书会成为 Swift 的经典入门书籍, 它的 Stars 数说明了一切</td>
</tr>
<tr>
<td><a href="http://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/" target="_blank" rel="external">The Swift Programming Language 中文版</a></td>
<td>90 后开发者梁杰组织翻译的 Swift 编程语言中文版</td>
</tr>
</tbody>
</table>
<h2 id="u535A_u5BA2"><a href="#u535A_u5BA2" class="headerlink" title="博客"></a>博客</h2><table>
<thead>
<tr>
<th>博客地址</th>
<th>博主信息</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://onevcat.com/#blog" target="_blank" rel="external">OneV’s Den</a></td>
<td>王巍(喵神), 现居日本, 就职于 LINE, 知名 iOS 开发者, 写的文章大多深入浅出, 内容广泛, 目前在维护的 <a href="http://swifter.tips" target="_blank" rel="external">Swifter</a> 也值得收藏</td>
</tr>
<tr>
<td><a href="http://blog.devtang.com" target="_blank" rel="external">唐巧的技术博客</a></td>
<td>唐巧, 国内知名 iOS 开发者, 现就职于猿题库, 博客推出的 iOS 移动开发周报很受欢迎, 更新频繁</td>
</tr>
<tr>
<td><a href="http://blog.txx.im" target="_blank" rel="external">txx’s blog</a></td>
<td>90 后 iOS 开发者, 人称虾神, 文章内容讲解大多浅白易懂, 很值得看</td>
</tr>
<tr>
<td><a href="http://beyondvincent.com" target="_blank" rel="external">破船之家</a></td>
<td>博主也是 iOS 大神一个, 经常更新一些 iOS 教程, 文章的质量都很高, 非常值得看</td>
</tr>
<tr>
<td><a href="http://nshipster.cn" target="_blank" rel="external">NSHipster</a></td>
<td>NSHipster 的中文网站, 主要对 NSHipster 的英文网站进行翻译, 博文出自 Mattt 大神之手, 文章大都写得很深入, 详细, 每周一更</td>
</tr>
<tr>
<td><a href="http://blog.leezhong.com" target="_blank" rel="external">Limboy 无网不剩</a></td>
<td>李忠, 知乎前员工, 目前在负责花瓣 iOS 开发, 不少文章里面有介绍博主个人的学习方法, 让读者在学到技术的同时也掌握学习的技巧</td>
</tr>
<tr>
<td><a href="http://nianxi.net" target="_blank" rel="external">念茜的博客</a></td>
<td>iOS 圈的女神人物, 写的关于安全问题的文章都值得一看, 由于新博客刚开通不久, 目前文章较少, 可以去看下她以前的<a href="http://blog.csdn.net/yiyaaixuexi" target="_blank" rel="external">博客</a></td>
</tr>
<tr>
<td><a href="http://weekly.ios-wiki.com/history" target="_blank" rel="external">iOS技术周报</a></td>
<td>吴发伟, 天猫资深软件开发工程师, iOS 技术周报每周一更, 推送一些 iOS 技巧, 代码库, 设计等资讯.</td>
</tr>
<tr>
<td><a href="http://www.iwangke.me" target="_blank" rel="external">iWangKe.me</a></td>
<td>王轲, IndieBros Studio 创始人, 优秀的 iOS 开发工程师, 写的文章深入浅出, 很多问题分析透彻, 非常有条理性</td>
</tr>
<tr>
<td><a href="http://www.jianshu.com/p/99e8b3f6f377" target="_blank" rel="external">叶孤城</a></td>
<td>叶孤城, 优秀 iOS 开发工程师, 发表的文章都有很多干货, 对源码解析类文章写得浅显易懂, 并时常总结一些 iOS 开发技巧, 值得一读</td>
</tr>
<tr>
<td><a href="http://zhowkev.in" target="_blank" rel="external">Kevin Blog</a></td>
<td>周楷雯, 秒视创始人, 知名 iOS 工程师, 做出了 <a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a> 和 <a href="https://github.com/kevinzhow/Waver" target="_blank" rel="external">Waver</a> 这样的好项目, 在博客中也有谈到具体的实现过程</td>
</tr>
<tr>
<td><a href="http://imtx.me" target="_blank" rel="external">IMTX</a></td>
<td>图拉鼎, 知名 Apple 平台开发者, 曾经的 Ubuntu 平台开发者, 文章有不少干货, 大多讲解技术实现和学习经验</td>
</tr>
<tr>
<td><a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" rel="external">更多</a></td>
<td>唐巧收集的中文 iOS/Mac 开发博客列表, 更新频繁, 值得收藏</td>
</tr>
</tbody>
</table>
<h2 id="u6587_u7AE0"><a href="#u6587_u7AE0" class="headerlink" title="文章"></a>文章</h2><table>
<thead>
<tr>
<th>标题</th>
<th>内容简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.udemy.com/blog/learn-objective-c" target="_blank" rel="external">Learn Objective C: The Path to iPhone Development</a></td>
<td>Udemy 写的文章, 说明了一些学习 Objective-C 的前提条件, Objective-C 的发展历史, 学习方法以及学习资源</td>
</tr>
<tr>
<td><a href="http://lifehacker.com/i-want-to-write-ios-apps-where-do-i-start-1644802175" target="_blank" rel="external">I Want to Write iOS Apps. Where Do I Start?</a></td>
<td>主要对 iOS 的开发环境进行了介绍, 并且涉及到了 Swift 的学习, iOS 上架的注意事项, iOS 的设计, 测试, 代码托管等, 讲解较为广泛, 同时也给出不少学习资源</td>
</tr>
<tr>
<td><a href="http://roadfiresoftware.com/2014/04/how-to-become-a-professional-ios-developer" target="_blank" rel="external">How to become a professional iOS developer</a></td>
<td>文章写的很有条理, 文中多次强调了版本控制系统的重要性, 主要内容是对学习 iOS 开发到就职, 给出了自己的建议</td>
</tr>
<tr>
<td><a href="http://codewithchris.com/learning-ios-programming" target="_blank" rel="external">Learning iOS Programming</a></td>
<td>作者总结了一些自己学习 iOS 的血的教训, 最后给出了一些不错学习建议</td>
</tr>
<tr>
<td><a href="https://www.udacity.com/career-paths/ios-developer" target="_blank" rel="external">Become an iOS Developer</a></td>
<td>作者列举了一些学习 iOS 的方法以及常用的库, 以及自学 iOS 的一些建议</td>
</tr>
<tr>
<td><a href="http://www.devtang.com/blog/2014/07/27/ios-levelup-tips" target="_blank" rel="external">iOS 开发如何提高</a></td>
<td>唐巧写的一篇文章, 主要是对 iOS 技术的提高做的一个总结, 文中不少资源, 工具, 学习方法</td>
</tr>
<tr>
<td><a href="http://limboy.me/ios/2014/12/31/learning-ios.html" target="_blank" rel="external">自学 iOS 开发的一些经验</a></td>
<td>文章从入门到进阶到高级, 分为三个阶段, 有条理的讲出了 iOS 的整个学习过程中开发者可能遇到的问题, 并给出了解决办法, 奉献了不少好工具, 资源还有珍贵的学习经验</td>
</tr>
<tr>
<td><a href="http://readful.com/post/101914515826/0-ios" target="_blank" rel="external">如何从 0 开始学 iOS 开发</a></td>
<td>作者给出了学习 iOS 的流程, 并给出一些不错的学习资源</td>
</tr>
<tr>
<td><a href="http://www.cocoachina.com/programmer/20141128/10353.html" target="_blank" rel="external">如果我可以重新学习 iOS 开发</a></td>
<td>作者在文中给出了学习的一些建议, 也谈到了自己的学习方法</td>
</tr>
<tr>
<td><a href="http://www.cocoachina.com/ios/20141106/10147.html" target="_blank" rel="external">iOS 开发学习路径的一些建议</a></td>
<td>文中谈到了英语的重要性, 以及写博客, 看源代码的好处</td>
</tr>
<tr>
<td><a href="http://www.jianshu.com/p/KSuDqb" target="_blank" rel="external">iOS 开发入门</a></td>
<td>作者分享了自己学习 iOS 的经验和资源</td>
</tr>
<tr>
<td><a href="http://beyondvincent.com/blog/2013/07/18/106" target="_blank" rel="external">Mac 和 iOS 开发资源汇总</a></td>
<td>破船之家发布的资源汇总</td>
</tr>
<tr>
<td><a href="http://www.raywenderlich.com/64546/introduction-to-cocoapods-2" target="_blank" rel="external">CocoaPods 使用教程</a></td>
<td>文章讲解了 CocoaPods 的基本使用, 并且配上 AFNetworking 做出了一个小 Demo, 值得一看</td>
</tr>
<tr>
<td><a href="http://www.coderyi.com/archives/397" target="_blank" rel="external">iOS 开发路线简述</a></td>
<td>作者简单介绍了一下自己 iOS 开发的感受，也是他学习 iOS 开发的一个体系架构。</td>
</tr>
</tbody>
</table>
<h2 id="u76F8_u5173_u7F51_u7AD9"><a href="#u76F8_u5173_u7F51_u7AD9" class="headerlink" title="相关网站"></a>相关网站</h2><table>
<thead>
<tr>
<th>网站</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://tutsplus.com/tutorials/search?utf8=%E2%9C%93&amp;search%5Btopic%5D=&amp;search%5Bterms%5D=ios&amp;button=" target="_blank" rel="external">tutsplus</a></td>
<td>不定时更新一些 iOS 教程</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/videos" target="_blank" rel="external">WWDC</a></td>
<td>苹果官方每年一度的 WWDC 视频, 可以了解历年有关 iOS 发布的内容</td>
</tr>
<tr>
<td><a href="http://asciiwwdc.com" target="_blank" rel="external">ASCIIwwdc</a></td>
<td>WWDC 的文字版</td>
</tr>
<tr>
<td><a href="https://swift.zeef.com/robin.eggenkamp" target="_blank" rel="external">Awesome Swift</a></td>
<td>该网站收集了很多关于 Swift 的学习资料, 新闻</td>
</tr>
<tr>
<td><a href="http://www.appcoda.com" target="_blank" rel="external">Appcoda</a></td>
<td>经常发布一些 iOS 编程教程, 更新比较频繁, 想了解更多可以查看该网站的 About 界面</td>
</tr>
<tr>
<td><a href="http://nshipster.com" target="_blank" rel="external">NSHipster</a></td>
<td>NSHipster is a journal of the overlooked bits in Objective-C, Swift, and Cocoa. Updated weekly.</td>
</tr>
<tr>
<td><a href="http://www.thinkandbuild.it" target="_blank" rel="external">Think and Build</a></td>
<td>Some tutorials about Core Graphic and Core Animation.</td>
</tr>
<tr>
<td><a href="http://www.raywenderlich.com/tutorials" target="_blank" rel="external">Tutorials</a></td>
<td>大把的 Objective-C, Swift, iOS 教程, 且全部免费, Raywenderlich 真是业界良心, 赞!</td>
</tr>
</tbody>
</table>
<h2 id="u793E_u533A"><a href="#u793E_u533A" class="headerlink" title="社区"></a>社区</h2><table>
<thead>
<tr>
<th>社区</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.cocoachina.com" target="_blank" rel="external">CocoaChina</a></td>
<td>全球最大苹果开发者中文社区</td>
</tr>
<tr>
<td><a href="http://code4app.com" target="_blank" rel="external">code4app</a></td>
<td>经常更新一些很不错的 iOS 代码片段和一些 iOS 资源</td>
</tr>
<tr>
<td><a href="http://www.objc.io" target="_blank" rel="external">objc</a></td>
<td>定期发布一些有关 Objective-C 的高质量的文章</td>
</tr>
<tr>
<td><a href="http://objccn.io" target="_blank" rel="external">objc中国</a></td>
<td>喵神组织的对 objc.io 的翻译网站, 旨在推进国内技术圈整体水平, 翻译质量非常高</td>
</tr>
<tr>
<td><a href="http://www.devdiv.com" target="_blank" rel="external">DevDiv</a></td>
<td>发布一些 iOS 的最新资讯及教程</td>
</tr>
<tr>
<td><a href="http://discuss.cocos2d-x.org" target="_blank" rel="external">Cocos2d-x</a></td>
<td>Cocos2d-x 论坛</td>
</tr>
<tr>
<td><a href="http://iphonedevsdk.com" target="_blank" rel="external">iPhone Dev SDK</a></td>
<td>国外较有名的 iOS 开发者论坛</td>
</tr>
<tr>
<td><a href="http://forum.learncocoa.org" target="_blank" rel="external">Learn Cocoa and iOS Development Forum</a></td>
<td><a href="http://www.amazon.com/Learn-Cocoa-Mac-Jack-Nutting/dp/1430245425" target="_blank" rel="external">Learn Cocoa on the Mac</a> 和 <a href="http://www.amazon.com/Beginning-iOS-Development-Exploring-SDK/dp/143026022X" target="_blank" rel="external">Beginning iOS 7 Development</a> 这两本书籍的官方论坛, 用户活跃度较高</td>
</tr>
<tr>
<td><a href="http://devforums.apple.com" target="_blank" rel="external">Apple Developer Forums</a></td>
<td>苹果官方的开发者论坛</td>
</tr>
<tr>
<td><a href="http://www.swiftist.org" target="_blank" rel="external">Swiftist</a></td>
<td>Swift 中文社区</td>
</tr>
</tbody>
</table>
<h2 id="u5DE5_u5177/_u63D2_u4EF6"><a href="#u5DE5_u5177/_u63D2_u4EF6" class="headerlink" title="工具/插件"></a>工具/插件</h2><table>
<thead>
<tr>
<th>工具/插件</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://cocoapods.org" target="_blank" rel="external">CocoaPods</a></td>
<td>开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具, 本身是 Ruby 的一个 Gem, 极大的简化了 Objective-C 的开发流程</td>
</tr>
<tr>
<td><a href="http://alcatraz.io" target="_blank" rel="external">Alcatraz</a></td>
<td>Alcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具</td>
</tr>
<tr>
<td><a href="https://github.com/robbiehanson/XcodeColors" target="_blank" rel="external">XcodeColors</a></td>
<td>使 Xcode 调试控制台色彩更丰富</td>
</tr>
<tr>
<td><a href="https://github.com/facebook/xctool" target="_blank" rel="external">xctool</a></td>
<td>Facebook 开源的一个 iOS 编译和测试的工具</td>
</tr>
<tr>
<td><a href="https://github.com/trawor/XToDo" target="_blank" rel="external">XToDo</a></td>
<td>一款注释辅助插件，主要用于收集并列出项目中的<code>TODO</code>, <code>FIXME</code>, <code>???</code>, <code>!!!</code></td>
</tr>
<tr>
<td><a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">KSImageNamed-Xcode</a></td>
<td>自动补全图片命名的一款插件</td>
</tr>
<tr>
<td><a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter</a></td>
<td>一个自动生成代码注释的工具</td>
</tr>
<tr>
<td><a href="https://imageoptim.com" target="_blank" rel="external">ImageOptim</a></td>
<td>用于压缩图片一款工具</td>
</tr>
<tr>
<td><a href="https://github.com/KrauseFx/fastlane" target="_blank" rel="external">fastlane</a></td>
<td>开发流程工具，将开发过程流程化，极大提高开发效率</td>
</tr>
<tr>
<td><a href="http://benscheirman.com/2013/08/the-ios-developers-toolbelt" target="_blank" rel="external">iOS 必备的 75 个工具</a></td>
<td>其中包含了非常多好用的工具, 涉及到设计, 分析, 部署等, 总结的十分详细, 有<a href="http://blog.jobbole.com/46799" target="_blank" rel="external">中文翻译</a></td>
</tr>
<tr>
<td><a href="http://blog.devtang.com/blog/2014/06/29/ios-dev-tools" target="_blank" rel="external">更多</a></td>
<td>唐巧总结的一些图形应用工具, 命令行工具, Xcode 插件, 并介绍了一点基础的用法</td>
</tr>
</tbody>
</table>
<h2 id="u6307_u5357/_u6559_u7A0B"><a href="#u6307_u5357/_u6559_u7A0B" class="headerlink" title="指南/教程"></a>指南/教程</h2><table>
<thead>
<tr>
<th>网址</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developer.apple.com/app-store/review/guidelines" target="_blank" rel="external">App Store Review Guidelines</a></td>
<td>iOS 应用商店审核指南, 有<a href="http://www.cocoachina.com/ios/20140227/7892.html" target="_blank" rel="external">中文翻译版</a></td>
</tr>
<tr>
<td><a href="http://dev.swiftguide.cn" target="_blank" rel="external">Swift 语言指南</a></td>
<td>有很多丰富的 Swift 学习资料, 学习 Swift 有这份资料可以省下很多力气</td>
</tr>
<tr>
<td><a href="http://ourcoders.com/thread/show/117" target="_blank" rel="external">苹果 Xcode 帮助文档阅读指南</a></td>
<td>Tinyfool 推出的一篇对于帮助新手阅读官方文档的指南</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/programs/ios/gettingstarted" target="_blank" rel="external">Get started with your iOS developer pragram</a></td>
<td>苹果写的一篇入门指南, 粗略讲解了 iOS 程序从开发到上架的整个流程</td>
</tr>
<tr>
<td><a href="http://blog.teamtreehouse.com/the-beginners-guide-to-objective-c-language-and-variables" target="_blank" rel="external">Teamtreehouse</a></td>
<td>文章主要讲解 Objective-C 的一些语法, 文章内容有趣且通俗易懂</td>
</tr>
<tr>
<td><a href="http://www.appdeveloperatlas.com" target="_blank" rel="external">A map for iOS development</a></td>
<td>一张 iOS 开发地图, 做得很赞, 看完对 iOS 开发流程有一定的认知</td>
</tr>
<tr>
<td><a href="https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOS" target="_blank" rel="external">Start Developing iOS Apps Today</a></td>
<td>苹果官方给出的 iOS 入门教程, 看过之后能够做一个 To-Do 小程序</td>
</tr>
<tr>
<td><a href="http://rypress.com/tutorials/objective-c" target="_blank" rel="external">Ry’s Objective-C Tutorial</a></td>
<td>讲解 Objective-C 的教程, 图文并茂, 适合新手阅读</td>
</tr>
<tr>
<td><a href="https://github.com/raywenderlich/objective-c-style-guide" target="_blank" rel="external">Objective-C Style Guide</a></td>
<td>Ray Wenderlich 推出的 Objective-C 风格指南</td>
</tr>
<tr>
<td><a href="http://www.shinobicontrols.com/iOS8DayByDay" target="_blank" rel="external">iOS8 Day-by-Day</a></td>
<td>每日一个 iOS8 的小教程, 所以的 DEMO 都可以在其 <a href="https://github.com/ShinobiControls/iOS8-day-by-day" target="_blank" rel="external">GitHub</a> 上面的找到相关代码</td>
</tr>
</tbody>
</table>
<h2 id="u90AE_u4EF6_u8BA2_u9605"><a href="#u90AE_u4EF6_u8BA2_u9605" class="headerlink" title="邮件订阅"></a>邮件订阅</h2><ul>
<li><a href="http://iosdevweekly.com" target="_blank" rel="external">iOS Dev Weekly</a> (每周一期，内容多为这一星期里值得关注的 GitHub 项目、文章、工具等)</li>
<li><a href="http://iosdesign.co" target="_blank" rel="external">iOS Design Weekly</a> (Tips, news and inspiration delivered each week)</li>
</ul>
<h2 id="u6587_u6863"><a href="#u6587_u6863" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a href="https://developer.apple.com/library/ios/navigation" target="_blank" rel="external">iOS Developer Library</a> (iOS 开发必看, 有此文档足矣, 内容非常之详细)</li>
</ul>
<h2 id="Awesome__u7CFB_u5217"><a href="#Awesome__u7CFB_u5217" class="headerlink" title="Awesome 系列"></a>Awesome 系列</h2><ul>
<li><a href="https://github.com/vsouza/awesome-ios" target="_blank" rel="external">Awesome iOS</a></li>
<li><a href="https://github.com/matteocrippa/awesome-swift" target="_blank" rel="external">Awesome-Swift(1)</a></li>
<li><a href="https://github.com/Wolg/awesome-swift" target="_blank" rel="external">Awesome-Swift(2)</a></li>
<li><a href="https://github.com/yenchenlin1994/awesome-watchos" target="_blank" rel="external">Awesome-watchOS</a></li>
</ul>
<h2 id="u77E5_u4E4E_u4E0A_u7684_u8BA8_u8BBA"><a href="#u77E5_u4E4E_u4E0A_u7684_u8BA8_u8BBA" class="headerlink" title="知乎上的讨论"></a>知乎上的讨论</h2><ul>
<li><a href="http://www.zhihu.com/question/20016551" target="_blank" rel="external">如何才能系统的学习 iOS 开发，理解一些规则和深层次的机制原理？</a></li>
<li><a href="http://www.zhihu.com/question/19627420" target="_blank" rel="external">没有 C 和 Objective-C 基础如何快速学习 iOS 开发？</a></li>
<li><a href="http://www.zhihu.com/question/20264108" target="_blank" rel="external">iOS 开发怎么入门?</a></li>
<li><a href="http://www.zhihu.com/question/20130048" target="_blank" rel="external">iOS 开发入门需要学习哪些知识，从一无所知到精通需要多长时间？</a></li>
<li><a href="http://www.zhihu.com/question/20919784" target="_blank" rel="external">12 岁如何入门 iOS 编程？</a></li>
<li><a href="http://www.zhihu.com/question/22914651" target="_blank" rel="external">GitHub 上都有哪些值得关注学习的 iOS 开源项目？</a></li>
</ul>
<h2 id="Quora__u4E0A_u7684_u8BA8_u8BBA"><a href="#Quora__u4E0A_u7684_u8BA8_u8BBA" class="headerlink" title="Quora 上的讨论"></a>Quora 上的讨论</h2><ul>
<li><a href="http://www.quora.com/What-are-the-best-resources-to-learn-iOS-development" target="_blank" rel="external">What are the best resources to learn iOS development?</a></li>
<li><a href="https://www.quora.com/What-are-the-best-new-resources-for-learning-iOS-development-in-2014" target="_blank" rel="external">What are the best new resources for learning iOS development in 2014?</a></li>
</ul>
<h2 id="u56FD_u5185_u77E5_u540D_u7684_u7A0B_u5E8F_u5458_u5F00_u53D1_u65E5_u62A5"><a href="#u56FD_u5185_u77E5_u540D_u7684_u7A0B_u5E8F_u5458_u5F00_u53D1_u65E5_u62A5" class="headerlink" title="国内知名的程序员开发日报"></a>国内知名的程序员开发日报</h2><ul>
<li><a href="http://app.memect.com" target="_blank" rel="external">App 开发日报</a></li>
<li><a href="http://toutiao.io" target="_blank" rel="external">开发者头条</a></li>
<li><a href="http://weekly.manong.io" target="_blank" rel="external">码农周刊</a></li>
</ul>
<h2 id="u8D21_u732E_u8005"><a href="#u8D21_u732E_u8005" class="headerlink" title="贡献者"></a>贡献者</h2><p>点击<a href="https://github.com/Aufree/trip-to-iOS/graphs/contributors" target="_blank" rel="external">该链接</a>查看该项目的所有贡献者</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>以上内容采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">CC BY-NC-SA 3.0</a> 进行许可, 转载请注明出处, 版权归本人及所有贡献者所有</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/07/2015-09-07-Swift语法-Swift/" itemprop="url">
                  Swift语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-07T00:00:00+08:00" content="2015-09-07">
              2015-09-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>来源：<a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/swift/</a></p>
<p>###空合运算符(Nil Coalescing Operator)<br>空合运算符(a ?? b)将对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b.这个运算符有两个条件:</p>
<ul>
<li><p>表达式a必须是Optional类型</p>
</li>
<li><p>默认值b的类型必须要和a存储值的类型保持一致</p>
</li>
</ul>
<p>空合并运算符是对以下代码的简短表达方法</p>
<pre><code>a != nil ? a! : b
</code></pre><p>上述代码使用了三目运算符。当可选类型a的值不为空时，进行强制解封(a!)访问a中值，反之当a中值为空时，返回默认值b。无疑空合运算符(??)提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以及更具可读性。</p>
<p>注意： 如果a为非空值(non-nil),那么值b将不会被估值。这也就是所谓的短路求值。<br>下文例子采用空合并运算符，实现了在默认颜色名和可选自定义颜色名之间抉择：</p>
<pre><code>let defaultColorName = &quot;red&quot;
var userDefinedColorName: String?   //默认值为 nil
var colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 &quot;red&quot;
</code></pre><p>userDefinedColorName变量被定义为一个可选String类型，默认值为nil。由于userDefinedColorName是一个可选类型，我们可以使用空合运算符去判断其值。在上一个例子中，通过空合运算符为一个名为colorNameToUse的变量赋予一个字符串类型初始值。 由于userDefinedColorName值为空，因此表达式userDefinedColorName ?? defaultColorName返回defaultColorName的值，即red。</p>
<p>另一种情况，分配一个非空值(non-nil)给userDefinedColorName，再次执行空合运算，运算结果为封包在userDefaultColorName中的值，而非默认值。</p>
<pre><code>userDefinedColorName = &quot;green&quot;
colorNameToUse = userDefinedColorName ?? defaultColorName
// userDefinedColorName 非空，因此 colorNameToUse 的值为 &quot;green&quot;
</code></pre><p>a = b ?? c 简而言之，如果b有值，那a就等于b，如果b为optional，则为c</p>
<p>###计算字符数量 (Counting Characters)<br>如果想要获得一个字符串中Character值的数量，可以使用字符串的characters属性的count属性，这个比较不一样，</p>
<pre><code>var word = &quot;cafe&quot;
word.characters.count
</code></pre><p>###字符串索引 (String Indices)</p>
<p>每一个String值都有一个关联的索引(index)类型，String.Index，它对应着字符串中的每一个Character的位置。</p>
<p>前面提到，不同的字符可能会占用不同数量的内存空间，所以要知道Character的确定位置，就必须从String开头遍历每一个 Unicode 标量直到结尾。因此，Swift 的字符串不能用整数(integer)做索引。</p>
<p>使用startIndex属性可以获取一个String的第一个Character的索引。使用endIndex属性可以获取最后一个Character的后一个位置的索引。因此，endIndex属性不能作为一个字符串的有效下标。如果String是空串，startIndex和endIndex是相等的。</p>
<p>通过调用String.Index的predecessor()方法，可以立即得到前面一个索引，调用successor()方法可以立即得到后面一个索引。任何一个String的索引都可以通过锁链作用的这些方法来获取另一个索引，也可以调用advancedBy(_:)方法来获取。但如果尝试获取出界的字符串索引，就会抛出一个运行时错误。</p>
<p>可以使用下标语法来访问String特定索引的Character。</p>
<pre><code>let greeting = &quot;Guten Tag!&quot;
greeting[greeting.startIndex]
// G
greeting[greeting.endIndex.predecessor()]
// !
greeting[greeting.startIndex.successor()]
// u
let index = greeting.startIndex.advancedBy(7)
greeting[index]
// a
</code></pre><p>试图获取越界索引对应的Character，将引发一个运行时错误。</p>
<pre><code>greeting[greeting.endIndex] // error
greeting.endIndex.successor() // error
</code></pre><p>使用characters属性的indices属性会创建一个包含全部索引的范围(Range)，用来在一个字符串中访问单个字符。</p>
<pre><code>for index in greeting.characters.indices {
    print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)
}
// 打印输出 &quot;G u t e n   T a g !&quot;
</code></pre><p>###插入和删除 (Inserting and Removing)</p>
<p>调用insert(_:atIndex:)方法可以在一个字符串的指定索引插入一个字符。</p>
<pre><code>var welcome = &quot;hello&quot;
welcome.insert(&quot;!&quot;, atIndex: welcome.endIndex)
// welcome now 现在等于 &quot;hello!&quot;
</code></pre><p>调用insertContentsOf(_:at:)方法可以在一个字符串的指定索引插入一个字符串。</p>
<pre><code>welcome.insertContentsOf(&quot; there&quot;.characters, at:     welcome.endIndex.predecessor())
// welcome 现在等于 &quot;hello there!&quot;
</code></pre><p>调用removeAtIndex(_:)方法可以在一个字符串的指定索引删除一个字符。</p>
<pre><code>welcome.removeAtIndex(welcome.endIndex.predecessor())
// welcome 现在等于 &quot;hello there&quot;
</code></pre><p>调用removeRange(_:)方法可以在一个字符串的指定索引删除一个子字符串。</p>
<pre><code>let range = welcome.endIndex.advancedBy(-6)..&lt;welcome.endIndex
welcome.removeRange(range)
// welcome 现在等于 &quot;hello&quot;
</code></pre><p>###前缀/后缀相等 (Prefix and Suffix Equality)</p>
<p>通过调用字符串的hasPrefix(:) / hasSuffix(_:)方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个String类型的参数，并返回一个布尔值。</p>
<p>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置：</p>
<pre><code>let romeoAndJuliet = [
    &quot;Act 1 Scene 1: Verona, A public place&quot;,
    &quot;Act 1 Scene 2: Capulet&apos;s mansion&quot;,
    &quot;Act 1 Scene 3: A room in Capulet&apos;s mansion&quot;,
    &quot;Act 1 Scene 4: A street outside Capulet&apos;s mansion&quot;,
    &quot;Act 1 Scene 5: The Great Hall in Capulet&apos;s mansion&quot;,
    &quot;Act 2 Scene 1: Outside Capulet&apos;s mansion&quot;,
    &quot;Act 2 Scene 2: Capulet&apos;s orchard&quot;,
    &quot;Act 2 Scene 3: Outside Friar Lawrence&apos;s cell&quot;,
    &quot;Act 2 Scene 4: A street in Verona&quot;,
    &quot;Act 2 Scene 5: Capulet&apos;s mansion&quot;,
    &quot;Act 2 Scene 6: Friar Lawrence&apos;s cell&quot;
]
</code></pre><p>您可以调用hasPrefix(_:)方法来计算话剧中第一幕的场景数：</p>
<pre><code>var act1SceneCount = 0
for scene in romeoAndJuliet {
    if scene.hasPrefix(&quot;Act 1 &quot;) {
       ++act1SceneCount
    }
}
print(&quot;There are \(act1SceneCount) scenes in Act 1&quot;)
// 打印输出 &quot;There are 5 scenes in Act 1&quot;
</code></pre><p>相似地，您可以用hasSuffix(_:)方法来计算发生在不同地方的场景数：</p>
<pre><code>var mansionCount = 0
var cellCount = 0
for scene in romeoAndJuliet {
    if scene.hasSuffix(&quot;Capulet&apos;s mansion&quot;) {
        ++mansionCount
    } else if scene.hasSuffix(&quot;Friar Lawrence&apos;s cell&quot;) {
        ++cellCount
    }
}
print(&quot;\(mansionCount) mansion scenes; \(cellCount) cell scenes&quot;)
// 打印输出 &quot;6 mansion scenes; 2 cell scenes&quot;
</code></pre><p>###基本集合操作</p>
<p>下面的插图描述了两个集合-a和b-以及通过阴影部分的区域显示集合各种操作的结果。</p>
<p><img src="http://cxray.github.io/images/setVennDiagram_2x.png" alt="setVennDiagram"></p>
<ul>
<li>使用intersect(:)方法根据两个集合中都包含的值创建的一个新的集合。</li>
<li>使用exclusiveOr(:)方法根据值在一个集合中但不在两个集合中的值创建一个新的集合。</li>
<li>使用union(:)方法根据两个集合的值创建一个新的集合。</li>
<li><p>使用subtract(:)方法根据不在该集合中的值创建一个新的集合。</p>
<pre><code>let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
oddDigits.union(evenDigits).sort()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersect(evenDigits).sort()
// []
oddDigits.subtract(singleDigitPrimeNumbers).sort()
// [1, 9]
oddDigits.exclusiveOr(singleDigitPrimeNumbers).sort()
// [1, 2, 9]
</code></pre></li>
</ul>
<p>集合成员关系和相等</p>
<p>下面的插图描述了三个集合-a,b和c,以及通过悬浮区域表述集合间共享的元素。Set a是Setb的父集合，因为a包含了b中所有的元素，相反的，Set b是a的子集合，因为属于b的元素也被a包含。Set b和Set c彼此不关联，因为它们之间没有共同的元素。</p>
<p><img src="http://cxray.github.io/images/setEulerDiagram_2x.png" alt="setEulerDiagram"></p>
<ul>
<li>使用“是否等”运算符(==)来判断两个集合是否包含全部相同的值。</li>
<li>使用isSubsetOf(_:)方法来判断一个集合中的值是否也被包含在另外一个集合中。</li>
<li>使用isSupersetOf(_:)方法来判断一个集合中包含的值是另一个集合中所有的值。</li>
<li>使用isStrictSubsetOf(:)或者isStrictSupersetOf(:)方法来判断一个集合是否是另外一个集合的子集合或者父集合并且和特定集合不相等。</li>
<li><p>使用isDisjointWith(_:)方法来判断两个结合是否不含有相同的值。</p>
<pre><code>let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]
let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]
let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]
houseAnimals.isSubsetOf(farmAnimals)
// true
farmAnimals.isSupersetOf(houseAnimals)
// true
farmAnimals.isDisjointWith(cityAnimals)
// true
</code></pre></li>
</ul>
<p>###检测API是否可用</p>
<p>Swift 有内置支持去检查接口的可用性的，这可以确保我们不会不小心地使用对于当前部署目标不可用的API。</p>
<p>编译器使用SDK中的可用信息来验证在我们在可用部署目标指定项目的代码中所有的API调用。如果我们尝试使用一个不可用的API，Swift会在编译期报错。</p>
<p>我们使用一个可用性条件在一个if或guard语句中去有条件的执行一段代码，这取决于我们想要使用的API是否在运行时是可用的。编译器使用从可用性条件语句中获取的信息，这时它会去验证在代码块中调用的API是否都可用。</p>
<pre><code>if #available(iOS 9, OSX 10.10, *) {
    // 在 iOS 使用 iOS 9 APIs , 并且在 OS X 使用 OS X v10.10 APIs
} else {
    // 回滚至早前 iOS and OS X 的API
}
</code></pre><p>以上可用性条件指定在iOS，if段的代码仅仅在iOS9及更高可运行；在OS X，仅在OS X v10.10及更高可运行。最后一个参数，*，是必须的并且指定在任何其他平台上，if段的代码在最小可用部署目标指定项目中执行。</p>
<p>在它普遍的形式中，可用性条件获取了平台名字和版本的清单。平台名字可以是iOS，OSX或watchOS。除了特定的主板本号像iOS8，我们可以指定较小的版本号像iOS8.3以及 OS X v10.10.3。</p>
<pre><code>if #available(`platform name` `version`, `...`, *) {
    `statements to execute if the APIs are available`
} else {
    `fallback statements to execute if the APIs are unavailable`
}
</code></pre><p>###闭包<br>闭包表达式语法有如下一般形式：</p>
<pre><code>{ (parameters) -&gt; returnType in
statements
}
</code></pre><p>闭包表达式语法可以使用常量、变量和inout类型作为参数，不提供默认值。 也可以在参数列表的最后使用可变参数。 元组也可以作为参数和返回值。</p>
<p>尾随闭包（Trailing Closures）<br>如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。 尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。</p>
<pre><code>func someFunctionThatTakesAClosure(closure: () -&gt; Void) {
// 函数体部分
}

// 以下是不使用尾随闭包进行函数调用
someFunctionThatTakesAClosure({
// 闭包主体部分
})

// 以下是使用尾随闭包进行函数调用
someFunctionThatTakesAClosure() {
// 闭包主体部分
}
</code></pre><p>函数是闭包的一种，闭包简化但让我难以理解，闭包可以在其定义的上下文中捕获常量或变量。 即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。注意避免强引用。</p>
<p>###枚举<br>枚举定义了一个通用类型的一组相关值</p>
<pre><code>enum CompassPoint {
case North
case South
case East
case West
}
</code></pre><p>用switch来匹配</p>
<pre><code>directionToHead = .South
switch directionToHead {
case .North:
    print(&quot;Lots of planets have a north&quot;)
case .South:
    print(&quot;Watch out for penguins&quot;)
case .East:
    print(&quot;Where the sun rises&quot;)
case .West:
    print(&quot;Where the skies are blue&quot;)
}
</code></pre><p>用switch必须穷举所有情况，否则用default</p>
<p>可以有原始值（Raw Values），这些原始值具有相同的类型。</p>
<pre><code>enum ASCIIControlCharacter: Character {
    case Tab = &quot;\t&quot;
    case LineFeed = &quot;\n&quot;
    case CarriageReturn = &quot;\r&quot;
}
</code></pre><p>递归枚举，这个我难以理解</p>
<p>在对操作符进行描述的时候，使用枚举类型来对数据建模很方便，因为需要考虑的情况固定可枚举。操作符可以将两个由数字组成的算数表达式连接起来，例如，将5连接成复杂一些的表达式5+4.</p>
<p>算数表达式的一个重要特性是，表达式可以嵌套使用。例如，表达式(5 + 4) * 2乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也许要支持这种嵌套————这表示枚举类型需要支持递归。</p>
<p>递归枚举（recursive enumeration）是一种枚举类型，表示它的枚举中，有一个或多个枚举成员拥有该枚举的其他成员作为相关值。使用递归枚举时，编译器会插入一个中间层。你可以在枚举成员前加上indirect来表示这成员可递归。</p>
<p>例如，下面的例子中，枚举类型存储了简单的算数表达式：</p>
<pre><code>enum ArithmeticExpression {
    case Number(Int)
    indirect case Addition(ArithmeticExpression, ArithmeticExpression)
    indirect case Multiplication(ArithmeticExpression, ArithmeticExpression)
</code></pre><p>}<br>你也可以在枚举类型开头加上indirect关键字来表示它的所有成员都是可递归的：</p>
<pre><code>indirect enum ArithmeticExpression {
    case Number(Int)
    case Addition(ArithmeticExpression, ArithmeticExpression)
    case Multiplication(ArithmeticExpression, ArithmeticExpression)
}
</code></pre><p>上面定义的枚举类型可以存储三种算数表达式：纯数字、两个表达式的相加、两个表达式相乘。Addition 和 Multiplication成员的相关值也是算数表达式————这些相关值使得嵌套表达式成为可能。</p>
<p>递归函数可以很直观地使用具有递归性质的数据结构。例如，下面是一个计算算数表达式的函数：</p>
<pre><code>func evaluate(expression: ArithmeticExpression) -&gt; Int {
    switch expression {
    case .Number(let value):
        return value
    case .Addition(let left, let right):
        return evaluate(left) + evaluate(right)
    case .Multiplication(let left, let right):
        return evaluate(left) * evaluate(right)
    }
}

// 计算 (5 + 4) * 2
let five = ArithmeticExpression.Number(5)
let four = ArithmeticExpression.Number(4)
let sum = ArithmeticExpression.Addition(five, four)
let product = ArithmeticExpression.Multiplication(sum,     ArithmeticExpression.Number(2))
print(evaluate(product))
// 输出 &quot;18&quot;
</code></pre><p>该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法元算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。</p>
<p>###计算属性,get&amp;set,这个以前没搞明白</p>
<p>除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>
<pre><code>struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
    size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print(&quot;square.origin is now at (\(square.origin.x), \    (square.origin.y))&quot;)
// 输出 &quot;square.origin is now at (10.0, 10.0)”
</code></pre><p>这个例子定义了 3 个结构体来描述几何形状：</p>
<ul>
<li>Point封装了一个(x, y)的坐标</li>
<li>Size封装了一个width和一个height</li>
<li>Rect表示一个有原点和尺寸的矩形</li>
</ul>
<p>Rect也提供了一个名为center的计算属性。一个矩形的中心点可以从原点（origin）和尺寸（size）算出，所以不需要将它以显式声明的Point来保存。Rect的计算属性center提供了自定义的 getter 和 setter 来获取和设置矩形的中心点，就像它有一个存储属性一样。</p>
<p>上述例子中创建了一个名为square的Rect实例，初始值原点是(0, 0)，宽度高度都是10。如下图中蓝色正方形所示。</p>
<p>square的center属性可以通过点运算符（square.center）来访问，这会调用该属性的 getter 来获取它的值。跟直接返回已经存在的值不同，getter 实际上通过计算然后返回一个新的Point来表示square的中心点。如代码所示，它正确返回了中心点(5, 5)。</p>
<p>center属性之后被设置了一个新的值(15, 15)，表示向右上方移动正方形到如下图橙色正方形所示的位置。设置属性center的值会调用它的 setter 来修改属性origin的x和y的值，从而实现移动正方形到新的位置。</p>
<p><img src="http://cxray.github.io/images/computedProperties_2x.png" alt="computedProperties_2x"></p>
<p>###便捷 setter 声明</p>
<p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称newValue。下面是使用了便捷 setter 声明的Rect结构体代码：</p>
<pre><code>struct AlternativeRect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set {
            origin.x = newValue.x - (size.width / 2)
            origin.y = newValue.y - (size.height / 2)
        }
    }
}
</code></pre><p>###只读计算属性</p>
<p>只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>
<p>注意：</p>
<p>必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>
<p>只读计算属性的声明可以去掉get关键字和花括号：</p>
<pre><code>struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
        return width * height * depth
    }
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
print(&quot;the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)&quot;)
// 输出 &quot;the volume of fourByFiveByTwo is 40.0&quot;
</code></pre><p>这个例子定义了一个名为Cuboid的结构体，表示三维空间的立方体，包含width、height和depth属性。结构体还有一个名为volume的只读计算属性用来返回立方体的体积。设置volume的值毫无意义，因为无法确定修改width、height和depth三者中的哪些值来匹配新的volume，从而造成歧义。然而，Cuboid提供一个只读计算属性来让外部用户直接获取体积是很有用的。</p>
<p>###属性观察器</p>
<p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新的值和现在的值相同的时候也不例外。</p>
<p>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重载属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。属性重载请参考重载。</p>
<p>注意：</p>
<p>不需要为非重载的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。</p>
<p>可以为属性添加如下的一个或全部观察器:</p>
<ul>
<li>willSet在新的值被设置之前调用</li>
<li>didSet在新的值被设置之后立即调用</li>
</ul>
<p>willSet观察器会将新的属性值作为常量参数传入，在willSet的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称newValue表示。</p>
<p>类似地，didSet观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名oldValue。</p>
<p>注意：</p>
<p>父类的属性在子类的构造器中被赋值时，它在父类中的willSet和didSet观察器会被调用。<br>有关构造器代理的更多信息，请参考值类型的构造器代理和类的构造器代理规则。</p>
<p>这里是一个willSet和didSet的实际例子，其中定义了一个名为StepCounter的类，用来统计当人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</p>
<pre><code>class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)
        }
        didSet {
            if totalSteps &gt; oldValue  {
                print(&quot;Added \(totalSteps - oldValue) steps&quot;)
            }
        }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
</code></pre><p>StepCounter类定义了一个Int类型的属性totalSteps，它是一个存储属性，包含willSet和didSet观察器。</p>
<p>当totalSteps设置新值的时候，它的willSet和didSet观察器都会被调用，甚至当新的值和现在的值完全相同也会调用。</p>
<p>例子中的willSet观察器将表示新值的参数自定义为newTotalSteps，这个观察器只是简单的将新的值输出。</p>
<p>didSet观察器在totalSteps的值改变后被调用，它把新的值和旧的值进行对比，如果总的步数增加了，就输出一个消息表示增加了多少步。didSet没有为旧的值提供自定义名称，所以默认值oldValue表示旧值的参数名。</p>
<p>注意：</p>
<p>如果在一个属性的didSet观察器里为它赋值，这个值会替换该观察器之前设置的值。</p>
<p>###计算型变量和计算型属性</p>
<p>如下形式声明一个一个存储型变量或存储型属性：</p>
<pre><code>var variable name: type {
    get {
        statements
    }
    set(setter name) {
        statements
    }
}
</code></pre><p>可以在全局，函数体内或者类，结构体，枚举，扩展声明的上下文中使用这种形式的声明。当变量以这种形式在全局或者一个函数内被声明时，它代表一个计算型变量(computed variable)。当它在类，结构体，枚举，扩展声明的上下文中中被声明时，它代表一个计算型变量(computed variable)。</p>
<p>getter用来读取变量值，setter用来写入变量值。setter子句是可选择的，只有getter是必需的，可以将这些语句 都省略，只是简单的直接返回请求值，正如在只读计算属性(Read-Only Computed Properties)中描述的那样。但是如果提供了一个setter语句，也必需提供一个getter语句。</p>
<p>setter的名字和圆括号内的语句是可选的。如果写了一个setter名，它就会作为setter的参数被使用。如果不写setter名，setter的初始名为’newValue’，正如在setter声明速记(Shorthand Setter Declaration)中提到的那样。</p>
<p>不像存储型变量和存储型属性那样，计算型属性和计算型变量的值不存储在内存中。</p>
<p>###存储型变量监视器和属性监视器</p>
<p>可以用willset和didset监视器来声明一个存储型变量或属性。一个包含监视器的存储型变量或属性按如下的形式声明：</p>
<pre><code>var variable name: type = expression {
    willSet(setter name) {
        statements
    }
    didSet(setter name) {
        statements
    }
}
</code></pre><p>可以在全局，函数体内或者类，结构体，枚举，扩展声明的上下文中使用这种形式的声明。当变量以这种形式在全局或者一个函数内被声明时，监视器代表一个存储型变量监视器(stored variable observers)；当它在类，结构体，枚举，扩展声明的上下文中被声明时，监视器代表属性监视器(property observers)。</p>
<p>可以为适合的监视器添加任何存储型属性。也可以通过重写子类属性的方式为适合的监视器添加任何继承的属性 (无论是存储型还是计算型的)，参见重写属性监视器(Overriding Property Observers)。</p>
<p>初始化表达式(expression)在一个类中或者结构体的声明中是可选的，但是在其他地方是必需的。当类型可以从初始化表达式(expression)中推断而来，那么这个类型(type)标注是可选的。</p>
<p>当变量或属性的值被改变时，willset和didset监视器提供了一个监视方法（适当的回应）。 监视器不会在变量或属性第一次初始化时运行，它们只有在值被外部初始化语句改变时才会被运行。</p>
<p>willset监视器只有在变量或属性值被改变之前运行。新的值作为一个常量经过过willset监视器，因此不可以在willset语句中改变它。didset监视器在变量或属性值被改变后立即运行。和willset监视器相反，为了以防止仍然需要获得旧的数据，旧变量值或者属性会经过didset监视器。这意味着，如果在变量或属性自身的didiset监视器语句中设置了一个值，设置的新值会取代刚刚在willset监视器中经过的那个值。</p>
<p>在willset和didset语句中，setter名(setter name)和圆括号的语句是可选的。如果写了一个setter名，它就会作为willset和didset的参数被使用。如果不写setter名， willset监视器初始名为newvalue，didset监视器初始名为oldvalue。</p>
<p>当提供一个willset语句时，didset语句是可选的。同样的，在提供了一个didset语句时，willset语句是可选的。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/04/2015-09-04-iOS一些UI基础-iOS/" itemprop="url">
                  iOS一些UI基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-04T00:00:00+08:00" content="2015-09-04">
              2015-09-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>出处是斯坦福公开课：iOS 8开发，<a href="http://www.swiftv.cn/course/i7ahl5gn" target="_blank" rel="external">http://www.swiftv.cn/course/i7ahl5gn</a></p>
</blockquote>
<p>数组的一些方法 Array<t> Methods</t></p>
<pre><code>var a = [a,b,c]
append(T)
insert(T,atIndex: Int)
splice(Array&lt;T&gt;,atIndex: Int)//连接一个数组
removeAtIndex(Int) //a.removeAtIndex(1), a = [a,c]
removeRange(Range) //a.removeRange(0..&lt;2), a = [c]
replaceRange(Range, [T]) //a.replaceRange(0...1,with: [x,y,z]), a = [x,y,z,c]
sort(isOrderedBefore: (T, T) -&gt; Bool)可以传人闭包（$0&lt;$1）

filter(includeElement: (T) -&gt; Bool) -&gt; [T] 
//可以去除一些不满足条件的数？
map(transform: (T) -&gt; U) -&gt; [u]
//let stringified: [String] = [1,2,3].map {&quot;\($0)&quot;} 
reduce(initial: U, combine:(U, T) -&gt; U) -&gt;U
//let sum: Int = [1,2,3].reduce(0) { $0 + $1 } **这三行我还不懂，没试过**
</code></pre><p>下面关于String.Index的内容</p>
<pre><code>var s = &quot;hello&quot;
let index = advance(s.startIndex, 1)//index是一个String.Index类
s.splice(&quot;abc&quot;, atIndex: index)//在s中插入abc，现在s为habcello
let startIndex = advance(s.startIndex, 1)
let endIndex = advance(s.startIndex, 6)
let substring = s[startIndex ..&lt; endIndex]//截取字符串，substring为abcel,如果改成s[1 ..&lt; 6]会报错
</code></pre><p>rangOfString 返回一个Optional Range<string.index>,用if let</string.index></p>
<pre><code>let num = &quot;56.25&quot;
if let decimalRange = num.rangeOfString(&quot;.&quot;){
    print(decimalRange)        //输出2..&lt;3
    let wholeNumberPart = num[num.startIndex ..&lt; decimalRange.endIndex]//wholeNumberPart = &quot;56.&quot;
}
</code></pre><p>removeRange &amp; replaceRange</p>
<pre><code>s.removeRange([s.startIndex ..&lt; s.endIndex])
//replaceRange(Range, String)
s = &quot;Hello&quot;
s.replaceRange(s.startIndex ..&lt; advance(s.startIndex, 3), with: &quot;aa&quot;)
</code></pre><p>其他一些String方法</p>
<pre><code>description -&gt; String
endIndex -&gt; String.Index
hasPrefix(String) -&gt; Bool
hsSuffix(String) -&gt; Bool
toInt() -&gt; Int?
capitalizedString -&gt; String
lowercaseString -&gt; String
uppercaseString -&gt; String
join(Array) -&gt; String    //&quot;,&quot;.join([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]) ＝ “1,2,3”
componentsSeparateByString(String) -&gt; [String] //“1,2,3”.csbs(&quot;,&quot;) = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]与join反一下
</code></pre><p>断言Assertions</p>
<pre><code>asseret(() -&gt; Bool. &quot;message&quot;)
</code></pre><p>其他一些函数，数组，字典，字符串中都可以使用</p>
<pre><code>let count = countElements(aCollection) //how many elements in the collection
let sub = dropFirst(aSliceable) //drops the first thing in the sliceable
let sub = dropLast(aSliceable) //drops the last thing in the sliceable
let first = first(aCollection) //the first element in the collection(or nil)
let last = last(aCollection) //the last element in the collection(or nil)
let prefix = prefix(aSliceable, X: Int) //returns the first x things
let suffix = suffix(aSliceable, X: Int) //return the last X things
let reversed: Array = reverse(aCollection) //remember that String is a collection
let backwardsString = String(reverse(s)) //so this is possible
</code></pre><p>显示类型转换</p>
<pre><code>let d: Double = 37.5
let f: Float = 37.5
let x = Int(d)
let xd = Double(x)
let cgf = CGFloat(d)

let a = Array(&quot;abc&quot;)
let s = String(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
</code></pre><p>CGFloat用于UIView上代替Double or Float，可以转换let cfg = CGFloat(aDouble)</p>
<p>CGPiont是一个简单的结构，由两个CGFloat x,y组成</p>
<pre><code>var point = CGPoint = CGPiont(x: 37.0, y: 55.2)
point.y -= 30
point.x += 20.0
</code></pre><p>CGSize也是一个简单的结构，由CGFloat width,height组成</p>
<pre><code>var size = CGSize(width: 100.0, height: 50.0)
size.width += 42.5
size.height += 75
</code></pre><p>CGRect是一个坐标，由CGPiont和CGSize组成的一个结构体</p>
<pre><code>struct CGRect {
    var origin: CGPiont
    var size: CGSize
}
intersects(CGRect) -&gt; Bool
intersect(CGRect)
contains(CGPoint) -&gt;Bool
</code></pre><p>画图Drawing</p>
<ul>
<li><p>当用户转置了手机，不应该重新画图而是重新摆放位置</p>
<pre><code>UIViewContentMode
//don&apos;t scale the view, just place it somewhere
.Left/.Right/.Top/.Bottom/.TopRight/.TopLeft/.BottomRight/.BottomLeft/.Center
//Scale the &quot;bits&quot; of the view...
.ScaleToFill/.ScaleAspectFill/.ScaleAspectFit// .ScaleToFill is defaule
Redraw by calling drawRect again
.Redraw
</code></pre></li>
</ul>
<ul>
<li><p>常见图形</p>
<pre><code>let roundRect = UIBezierPath(roundedRect: aCGRect, cornerRadius: aCGFloat)
let oval = UIBezierPath(ovalInRect: aCGRect)
</code></pre></li>
<li><p>修剪图形</p>
<pre><code>addClip()
</code></pre></li>
<li><p>碰撞检测</p>
<pre><code>func containsPoint(CGPoint) -&gt; Bool
</code></pre></li>
<li><p>定义路径 Defining a Path</p>
<pre><code>    //Create a UIBezierPath
let path = UIBezierPath()
    //Move around, add lines or arcs to the path
path.moveToPoint(CGPoint(80,50))
    //close the path(if you want)
path.addLineToPoint(CGPoint(140,150))
path.addLineToPoint(CGPoint(10,150))
path.closePath()
UIColor.greenColor().setFill()
UIColor.redColor().setFill()
    //注意是UIColor中的一个方法
path.lineWidth = 3.0
path.fill()
path.stroke()
    //画出图形
</code></pre></li>
<li><p>UIColor透明度</p>
<pre><code>let transparenYellow = UIColor.yellowColor().colorWithAlphaComponent(0.5)
//0.0透明，1.0不透明
</code></pre></li>
</ul>
<p>字体，系统有推荐字体</p>
<pre><code>class func preferredFontForTextStyly(UIFontTextStyle) -&gt; UIFont
UIFontTextStyle.Headline
UIFontTextStyle.Body
UIFontTextStyle.Footnote
//系统字体
class func systemFontOfSize(pointSize: CGFloat) -&gt; UIFont
class func boldSystemFontOfSize(pointSize: CGFloat) -&gt; UIFont
</code></pre><p>手势Gestures</p>
<pre><code>UIPinchGestureRecognizer//捏合
UIRotationGestureRecognizer//旋转
UISwipeGestureRecognizer//滑动
UITapGestureRecongnizer//轻触
</code></pre><p>密文显示</p>
<pre><code>secuieTextEntry
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/03/2015-09-03-打赏功能的实现-网页设计/" itemprop="url">
                  打赏功能的实现————tctip侧边按钮
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-03T00:00:00+08:00" content="2015-09-03">
              2015-09-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网页设计/" itemprop="url" rel="index">
                    <span itemprop="name">网页设计</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>非常感谢原作者的js插件和提供的服务器</p>
<blockquote>
<p><a href="https://github.com/greedying/tctip" target="_blank" rel="external">https://github.com/greedying/tctip</a></p>
</blockquote>
<p>这是它的仓库</p>
<pre><code>&lt;script&gt;
window.tctipConfig = {
        staticPrefix: &quot;http://static.tctip.com&quot;,
        buttonImageId: 3,
        buttonTip:    &quot;dashang&quot;,
        list:{
            alipay: { qrimg: &quot;这里放图片地址&quot;},
            weixin: { qrimg: &quot;这里放图片地址&quot;},
        }
    };
&lt;/script&gt;
&lt;script src=&quot;http://static.tctip.com/js/tctip.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>我用了它这么一小段代码就能实现了，本来想去掉了解更多和喜欢请打赏，发现我还虚着，折腾来折腾去没弄掉它，如果要自己修改的话，网页里还要多出一些文件</p>
<p>隐藏在右边非常简洁，但在手机端有些问题，打开了就按不回去了。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/02/2015-09-02-大一的尾巴-瞎扯/" itemprop="url">
                  大一的尾巴
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-02T00:00:00+08:00" content="2015-09-02">
              2015-09-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/瞎扯/" itemprop="url" rel="index">
                    <span itemprop="name">瞎扯</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>大一很快的结束了，整个大一很感谢加入了ACM队和虞歌老师的实验室里，ACM队感觉难以融入他们，自己面对算法也露出了疲态，没有当初那种澎湃的心情了，大概面对一次次的WrongAnswer或者是读完题目根本没什么思路被打败了，至于虞歌实验室里，自己的确学了一些Swift和OC，但是一做UI的时候就蒙逼了，还是慢慢磕这两个吧，网站建的这样也差不多了，能找到个地方写东西就好，stayreal.wang是搭在了阿里云上，估计两年之后我就没钱续费了，博客直接搭在了Github上，先放着吧。</p>
<p>Swift和OC还有些奇技淫巧，高深的语法没懂。网站都是靠模版的，Ruby，Css，JS，Jekyll什么的都还一窍不通，都是跪着看完网上杂乱的说明搭出来的。整个大一，学了一点点的C和C++。</p>
<p>大一暑假吧，主要是为了暑期社会实践的分，ACM队集训了一个月，如果没有这个的话我可能也会呆实验室呆上几个礼拜吧，集训的最后几天，可能是我厌烦了，一点点代码都没动力写，还有就是食堂的饭菜太差了，就根本不想呆学校了。集训也不能说没什么用，至少多理解了一点点的堆栈链表吧，和简单的看了下Java。</p>
<p>8月13号下午回的家，剩下差不多还有3个礼拜给我放假呆家里，学了几天车，把驾照考出了，也是完成了一件人生必需的事，去万象城直营店买了一台MacBook，很感激我爸这么给我投资，这样我一定要走好iOS这条路，希望Swift能健壮起来吧，可能这个暑假是我最有意义的一个暑假，在家里这几天，只和高中关系比较好的几个同学见了两次面，但和PTK一条消息都没发过，可能以后就分道扬镳，很难再去和她聊天了吧，以前关系很好现在却只能这样也是一种悲哀，这真是很难过。最后的温柔是不打扰。</p>
<p>整个大一陪伴我的还有青年志愿者协会多媒体技术部门，名字一定要打全了，万一以后忘了呢，尽管我是那么的讨厌做视频做iebook，但我认识了一群很团结很善良很纯真很友好很热情的朋友，每个礼拜四晚上开会，隔几天就约的一个部门。关于青协的回忆总是甜的，不过很遗憾我在青协呆了一年没有参加志愿者。</p>
<p>而整个大一让我最不爽的是，寝室里其他三人在打游戏看电影听音乐什么的，而你在敲代码看书的话，就会被别人说装逼，在教室里听课，别人都在玩手机而你在看书或是开着台电脑敲代码，又会被说装逼，还tm有些人起哄和别人说你装逼，真tm是一肚子火。下面有两个知乎的评论</p>
<p><a href="http://www.zhihu.com/question/30362260" target="_blank" rel="external">在宿舍写代码总被一个室友认为在装逼，该怎么办？</a></p>
<p><a href="http://www.zhihu.com/question/22251192" target="_blank" rel="external">为什么我总被骂装逼？也就是遭到讽刺性语言攻击？</a></p>
<p>感觉只有这句话最好了</p>
<pre><code>If you&apos;re the smartest person in the room, you&apos;re in the wrong room
</code></pre><p>我其他无话可说，只能好好走自己的路，让别人说去吧。</p>
<p>还有一开学居然就要体测，艹呆在家里都呆虚了然后去体测，每次都想下去跑一圈但是总被懒惰给制止了，开学肯定要虚了。</p>
<p>大一就这样吧，希望和室友好好相处完这几年点大学吧。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/01/2015-09-01-HelloWorld-瞎扯/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-01T00:00:00+08:00" content="2015-09-01">
              2015-09-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/瞎扯/" itemprop="url" rel="index">
                    <span itemprop="name">瞎扯</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>在网上找了半天，真的是乱七八糟，对于新手真的是凶残</p>
<p>git把我电脑现在搞得一团糟，结果发现用Github desktop轻轻松松搞定</p>
<p>Jekyll也把我终端给搞砸了，现在弄不好了，算了先放着吧</p>
<p>还有一堆英文的名词把我搞的一团雾水，那些写的博客都默认能懂了，真的是开头一把幸酸泪</p>
<p>写这玩意居然说markdown，我一直以为是html写的</p>
<p>终于搞的差不多，博客有点样子出来了。</p>
<blockquote>
<p>下面附上一个网站</p>
</blockquote>
<p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">http://wowubuntu.com/markdown/</a></p>
<p>学Markdown的好地方</p>
<blockquote>
<p>这里演示一下Markdowm在网页中显示，以便查看各种效果</p>
</blockquote>
<h1 id="Mou"><a href="#Mou" class="headerlink" title="Mou"></a>Mou</h1><p><img src="http://25.io/mou/Mou_128.png" alt="Mou icon"></p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><strong>Mou</strong>, the missing Markdown editor for <em>web developers</em>.</p>
<h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><h4 id="Strong_and_Emphasize"><a href="#Strong_and_Emphasize" class="headerlink" title="Strong and Emphasize"></a>Strong and Emphasize</h4><p><strong>strong</strong> or <strong>strong</strong> ( Cmd + B )</p>
<p><em>emphasize</em> or <em>emphasize</em> ( Cmd + I )</p>
<p><strong>Sometimes I want a lot of text to be bold.<br>Like, seriously, a <em>LOT</em> of text</strong></p>
<h4 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h4><blockquote>
<p>Right angle brackets &gt; are used for block quotes.</p>
</blockquote>
<h4 id="Links_and_Email"><a href="#Links_and_Email" class="headerlink" title="Links and Email"></a>Links and Email</h4><p>An email <a href="/&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#101;&#120;&#x61;&#x6d;&#112;&#108;&#101;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;">&#101;&#120;&#x61;&#x6d;&#112;&#108;&#101;&#64;&#x65;&#x78;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a> link.</p>
<p>Simple inline link <a href="http://chenluois.com" target="_blank" rel="external">http://chenluois.com</a>, another inline link <a href="http://25.io/smaller/" target="_blank" rel="external">Smaller</a>, one more inline link with title <a href="http://resizesafari.com" title="a Safari extension" target="_blank" rel="external">Resize</a>.</p>
<p>A <a href="http://25.io/mou/" title="Markdown editor on Mac OS X" target="_blank" rel="external">reference style</a> link. Input id, then anywhere in the doc, define the link with corresponding id:</p>
<p>Titles ( or called tool tips ) in the links are optional.</p>
<h4 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h4><p>An inline image <img src="http://25.io/smaller/favicon.ico" alt="Smaller icon" title="Title here">, title is optional.</p>
<p>A <img src="http://resizesafari.com/favicon.ico" alt="Resize icon" title="Title"> reference style image.</p>
<h4 id="Inline_code_and_Block_code"><a href="#Inline_code_and_Block_code" class="headerlink" title="Inline code and Block code"></a>Inline code and Block code</h4><p>Inline code are surround by <code>backtick</code> key. To create a block code:</p>
<pre><code>Indent each line by at least 1 tab, or 4 spaces.
var Mou = exactlyTheAppIwant; 
</code></pre><h4 id="Ordered_Lists"><a href="#Ordered_Lists" class="headerlink" title="Ordered Lists"></a>Ordered Lists</h4><p>Ordered lists are created using “1.” + Space:</p>
<ol>
<li>Ordered list item</li>
<li>Ordered list item</li>
<li>Ordered list item</li>
</ol>
<h4 id="Unordered_Lists"><a href="#Unordered_Lists" class="headerlink" title="Unordered Lists"></a>Unordered Lists</h4><p>Unordered list are created using “*” + Space:</p>
<ul>
<li>Unordered list item</li>
<li>Unordered list item</li>
<li>Unordered list item </li>
</ul>
<p>Or using “-“ + Space:</p>
<ul>
<li>Unordered list item</li>
<li>Unordered list item</li>
<li>Unordered list item</li>
</ul>
<h4 id="Hard_Linebreak"><a href="#Hard_Linebreak" class="headerlink" title="Hard Linebreak"></a>Hard Linebreak</h4><p>End a line with two or more spaces will create a hard linebreak, called <code>&lt;br /&gt;</code> in HTML. ( Control + Return )<br>Above line ended with 2 spaces.</p>
<h4 id="Horizontal_Rules"><a href="#Horizontal_Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h4><p>Three or more asterisks or dashes:</p>
<hr>
<hr>
<hr>
<h4 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h4><p>Setext-style:</p>
<h1 id="This_is_H1"><a href="#This_is_H1" class="headerlink" title="This is H1"></a>This is H1</h1><h2 id="This_is_H2"><a href="#This_is_H2" class="headerlink" title="This is H2"></a>This is H2</h2><p>atx-style:</p>
<h1 id="This_is_H1-1"><a href="#This_is_H1-1" class="headerlink" title="This is H1"></a>This is H1</h1><h2 id="This_is_H2-1"><a href="#This_is_H2-1" class="headerlink" title="This is H2"></a>This is H2</h2><h3 id="This_is_H3"><a href="#This_is_H3" class="headerlink" title="This is H3"></a>This is H3</h3><h4 id="This_is_H4"><a href="#This_is_H4" class="headerlink" title="This is H4"></a>This is H4</h4><h5 id="This_is_H5"><a href="#This_is_H5" class="headerlink" title="This is H5"></a>This is H5</h5><h6 id="This_is_H6"><a href="#This_is_H6" class="headerlink" title="This is H6"></a>This is H6</h6><h3 id="Extra_Syntax"><a href="#Extra_Syntax" class="headerlink" title="Extra Syntax"></a>Extra Syntax</h3><h4 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h4><p>Footnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this:</p>
<p>That’s some text with a footnote.[^1]</p>
<p>[^1]: And that’s the footnote.</p>
<h4 id="Strikethrough"><a href="#Strikethrough" class="headerlink" title="Strikethrough"></a>Strikethrough</h4><p>Wrap with 2 tilde characters:</p>
<p><del>Strikethrough</del></p>
<h4 id="Fenced_Code_Blocks"><a href="#Fenced_Code_Blocks" class="headerlink" title="Fenced Code Blocks"></a>Fenced Code Blocks</h4><p>Start with a line containing 3 or more backticks, and ends with the first line with the same number of backticks:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fenced code blocks are like Stardard Markdown&#8217;s regular code&#10;blocks, except that they&#8217;re not indented and instead rely on&#10;a start and end fence lines to delimit the code block.</span><br></pre></td></tr></table></figure>
<h4 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h4><p>A simple table looks like this:</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
<th>Third Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody>
</table>
<p>If you wish, you can add a leading and tailing pipe to each line of the table:</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
<th>Third Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody>
</table>
<p>Specify alignment for each column by adding colons to separator lines:</p>
<table>
<thead>
<tr>
<th style="text-align:left">First Header</th>
<th style="text-align:center">Second Header</th>
<th style="text-align:right">Third Header</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Left</td>
<td style="text-align:center">Center</td>
<td style="text-align:right">Right</td>
</tr>
<tr>
<td style="text-align:left">Left</td>
<td style="text-align:center">Center</td>
<td style="text-align:right">Right</td>
</tr>
</tbody>
</table>
<h3 id="Shortcuts"><a href="#Shortcuts" class="headerlink" title="Shortcuts"></a>Shortcuts</h3><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><ul>
<li>Toggle live preview: Shift + Cmd + I</li>
<li>Toggle Words Counter: Shift + Cmd + W</li>
<li>Toggle Transparent: Shift + Cmd + T</li>
<li>Toggle Floating: Shift + Cmd + F</li>
<li>Left/Right = 1/1: Cmd + 0</li>
<li>Left/Right = 3/1: Cmd + +</li>
<li>Left/Right = 1/3: Cmd + -</li>
<li>Toggle Writing orientation: Cmd + L</li>
<li>Toggle fullscreen: Control + Cmd + F</li>
</ul>
<h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><ul>
<li>Copy HTML: Option + Cmd + C</li>
<li>Strong: Select text, Cmd + B</li>
<li>Emphasize: Select text, Cmd + I</li>
<li>Inline Code: Select text, Cmd + K</li>
<li>Strikethrough: Select text, Cmd + U</li>
<li>Link: Select text, Control + Shift + L</li>
<li>Image: Select text, Control + Shift + I</li>
<li>Select Word: Control + Option + W</li>
<li>Select Line: Shift + Cmd + L</li>
<li>Select All: Cmd + A</li>
<li>Deselect All: Cmd + D</li>
<li>Convert to Uppercase: Select text, Control + U</li>
<li>Convert to Lowercase: Select text, Control + Shift + U</li>
<li>Convert to Titlecase: Select text, Control + Option + U</li>
<li>Convert to List: Select lines, Control + L</li>
<li>Convert to Blockquote: Select lines, Control + Q</li>
<li>Convert to H1: Cmd + 1</li>
<li>Convert to H2: Cmd + 2</li>
<li>Convert to H3: Cmd + 3</li>
<li>Convert to H4: Cmd + 4</li>
<li>Convert to H5: Cmd + 5</li>
<li>Convert to H6: Cmd + 6</li>
<li>Convert Spaces to Tabs: Control + [</li>
<li>Convert Tabs to Spaces: Control + ]</li>
<li>Insert Current Date: Control + Shift + 1</li>
<li>Insert Current Time: Control + Shift + 2</li>
<li>Insert entity &lt;: Control + Shift + ,</li>
<li>Insert entity &gt;: Control + Shift + .</li>
<li>Insert entity &amp;: Control + Shift + 7</li>
<li>Insert entity Space: Control + Shift + Space</li>
<li>Insert Scriptogr.am Header: Control + Shift + G</li>
<li>Shift Line Left: Select lines, Cmd + [</li>
<li>Shift Line Right: Select lines, Cmd + ]</li>
<li>New Line: Cmd + Return</li>
<li>Comment: Cmd + /</li>
<li>Hard Linebreak: Control + Return</li>
</ul>
<h4 id="Edit"><a href="#Edit" class="headerlink" title="Edit"></a>Edit</h4><ul>
<li>Auto complete current word: Esc</li>
<li>Find: Cmd + F</li>
<li>Close find bar: Esc</li>
</ul>
<h4 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h4><ul>
<li>Post on Scriptogr.am: Control + Shift + S</li>
<li>Post on Tumblr: Control + Shift + T</li>
</ul>
<h4 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h4><ul>
<li>Export HTML: Option + Cmd + E</li>
<li>Export PDF:  Option + Cmd + P</li>
</ul>
<h3 id="And_more_3F"><a href="#And_more_3F" class="headerlink" title="And more?"></a>And more?</h3><p>Don’t forget to check Preferences, lots of useful options are there.</p>
<p>Follow <a href="https://twitter.com/mou" target="_blank" rel="external">@Mou</a> on Twitter for the latest news.</p>
<p>For feedback, use the menu <code>Help</code> - <code>Send Feedback</code></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/headImage.JPG" alt="Ray" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Ray</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Live For The Dream!</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CXRay" target="_blank">
                  <i class="fa fa-github"></i> github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1795459455/" target="_blank">
                  <i class="fa fa-weibo"></i> weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.instagram.com/ray_oooooo/" target="_blank">
                  <i class="fa fa-instagram"></i> instagram
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
