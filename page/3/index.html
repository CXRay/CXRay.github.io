<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>


    <meta name="description" content="Live For The Dream!" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description" content="Live For The Dream!">
<meta property="og:type" content="website">
<meta property="og:title" content="Ray">
<meta property="og:url" content="http://cxray.github.io/page/3/index.html">
<meta property="og:site_name" content="Ray">
<meta property="og:description" content="Live For The Dream!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ray">
<meta name="twitter:description" content="Live For The Dream!">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> Ray </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Ray</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">subtitle</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/10/09/2015-10-09-UISegmentedControl学习-iOS/" itemprop="url">
                  UISegmentedControl学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-10-09T00:00:00+08:00" content="2015-10-09">
              2015-10-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>这个分段控件也不难，只是一些属性记记住就好了</p>
<blockquote>
<p>创建数组和segment</p>
</blockquote>
<pre><code>var appsArray = [&quot;StayReal&quot;,&quot;CXRay&quot;,&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]
var segment: UISegmentedControl!
</code></pre><blockquote>
<p>在ViewDidLoad中初始化，并添加到视图</p>
</blockquote>
<pre><code>//创建分段控件
segment = UISegmentedControl(items: appsArray)
//设置大小
segment.frame = CGRectMake(20, 100, 320, 40)
//添加到视图
self.view.addSubview(segment)
</code></pre><blockquote>
<p>分段控件常用属性和方法</p>
</blockquote>
<pre><code>//默认选中下标为1的
segment.selectedSegmentIndex = 1

//获取选中的坐标,这个属性可读可写
let index = segment.selectedSegmentIndex
print(index)

//获取segment的数量
let count = segment.numberOfSegments
print(count)

//设置下标等于2的标题
segment.setTitle(&quot;ddd&quot;, forSegmentAtIndex: 2)

//设置下标等于3的图片，图片和标题不能共存，设置了图片之后，原来的标题就不显示了,可是这个图片有要求，这里有些问题
segment.setImage(UIImage(named: &quot;1033382.png&quot;), forSegmentAtIndex: 3)

//在坐标为2的位置，插入一个分段标题
segment.insertSegmentWithTitle(&quot;insert&quot;, atIndex: 2, animated: true)
//同理可插入图片
segment.insertSegmentWithImage(image: UIImage?, atIndex: Int, animated: Bool)

//获取某一下标下的标题
let title = segment.titleForSegmentAtIndex(0)
//获取某一下标下的图片
let image = segment.imageForSegmentAtIndex(3)

//momentary默认为NO，点击之后一直处于选中状态，除非点击其它分段，才恢复，当设置成YES时，点击选中，但一会儿就恢复到正常状态,一般设置成false吧，除非特殊要求
segment.momentary = false

//设置某一分段是否可用
segment.setEnabled(false, forSegmentAtIndex: 1)

//设置下标为0的segment的宽度
segment.setWidth(100, forSegmentAtIndex: 0)

//获取某一下标的segment的宽度,如果是默认会输出0.0
let width = segment.widthForSegmentAtIndex(2)
print(width)

//设置内容偏移
segment.setContentOffset(CGSizeMake(10, 10), forSegmentAtIndex: 2)

//获取某一个下标segment的内容偏移
let size = segment.contentOffsetForSegmentAtIndex(3)
print(size)

//是否根据segment的内容改变其宽度
segment.apportionsSegmentWidthsByContent = true

//设置标题颜色
segment.tintColor = UIColor.redColor()

//获取标题颜色,颜色可读可写
let segmentColor = segment.tintColor
print(segmentColor)

//移除下标为2的segment
segment.removeSegmentAtIndex(4, animated: true)

//移除所有segment
//segment.removeAllSegments()
</code></pre><blockquote>
<p>添加事件，当segment改变时，触发</p>
</blockquote>
<pre><code>segment.addTarget(self, action: &quot;segmentChange:&quot;, forControlEvents: UIControlEvents.ValueChanged)

func segmentChange(sender: AnyObject)
{
    let segment: UISegmentedControl = sender as! UISegmentedControl
    switch segment.selectedSegmentIndex
    {
    case 0:
        print(&quot;0&quot;)
    case 1:
        print(&quot;1&quot;)
    case 2:
        print(&quot;2&quot;)
    case 3:
        print(&quot;3&quot;)
    default:
        print(&quot;defaule&quot;)
    }
}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/10/07/2015-10-07-对于Vim的学习-Vim/" itemprop="url">
                  对于Vim的学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-10-07T00:00:00+08:00" content="2015-10-07">
              2015-10-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Vim/" itemprop="url" rel="index">
                    <span itemprop="name">Vim</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Vim不得不说用好了是个神器啊，这篇慢慢的纪录我对Vim的学习</p>
<p>hjkl  代表左下上右</p>
<p>.  重复上一次操作</p>
<p>x  删除光标下的字符</p>
<p>dd  删除当前行</p>
<pre><code>&gt;G  增加从当前行到文档末尾处的缩进层级
</code></pre><p>$  快速移动到本行最后</p>
<p>A  移动到本行进入插入模式</p>
<p>f后加一个字符，如fa，f＋  快速移动到本行第一个字符，a ＋ ，这个看起来很好用</p>
<p>u 撤销(undo)</p>
<pre><code>*  查找，把它放在一个单词上就能快速查找，如果没有高亮显示，输入:set hls，再输入n代表next查找下一个单词
</code></pre><p>cw  删除从光标位置到单词结尾字符，并进入插入模式，这个可以配合查找，.重复执行上一步，可以进行快速替换</p>
<p>反向删除单词</p>
<p>db  删除从光标起始位置到单词开头的内容，但会原封不动的留下最后一个字符，再摁下x就能从最后把一个单词删掉</p>
<p>正向删除单词</p>
<p>b  将光标移动到单词开头</p>
<p>dw 删除从光标起始位置到单词结尾的内容</p>
<p>删除整个单词</p>
<p>daw  可以记忆成delete a word,多用这个，因为它可以用.命令进行重复</p>
<p>用次数做简单运算</p>
<p><c -="" a=""> 和 <c -="" x=""> 命令分别对数字进行加和减操作，如果前面加上一个次数前缀，那么就可以用他们加减任意整数,但如果光标不在数字上，那么<c -="" a="">会在当前行正向查找一个数字，如果找到了就会径直跳到那里,并执行加</c></c></c></p>
<p>yyp 复制当前行</p>
<p>Vim操作符命令，操作符＋ 动作命令 ＝ 操作</p>
<p>c  修改</p>
<p>y  复制到寄存器</p>
<p>d  删除</p>
<p>g~ gu gU   分别为反转大小写，转换为小写，转换为大写，但要执行两次</p>
<blockquote>
<p>&lt; =  分别为增加缩进，减小缩进，自动缩进，也要摁两次</p>
</blockquote>
<p>在插入模式下，也可以用到命令，<c -="" h=""> 代表删除前一个字符，同退格键 <c -="" w="">删除前一个单词  <c -="" u=""> 删除一行</c></c></c></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/10/06/2015-10-06-UITextView学习-iOS/" itemprop="url">
                  UITextView学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-10-06T00:00:00+08:00" content="2015-10-06">
              2015-10-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>这个控件也很容易，毕竟只是写文字上的东西</p>
<blockquote>
<p>创建UITextView，前面要加一个代理UITextViewDelegate</p>
</blockquote>
<pre><code>//创建UITextView对象
var textView = UITextView(frame: CGRectMake(10, 120, 300, 400))
</code></pre><blockquote>
<p>设置颜色，字体，内容，对齐方式，键盘类型等等</p>
</blockquote>
<pre><code>textView.backgroundColor = UIColor.grayColor()
self.view.addSubview(textView)
textView.delegate = self

//设置textView字体颜色
textView.textColor = UIColor.greenColor()
//设置文本字体
textView.font = UIFont.systemFontOfSize(18)
textView.font = UIFont(name: &quot;Helvetica-Bold&quot;, size: 18)
//内容
textView.text = &quot;aaaaa\nbbbbbb\ncccccccc\nddddd\nc\nd\ne\nf\ng\nh\ni\nj\nk\nl\nm\nn\no\np\nq\nr\ns\nt\n&quot;

//文本对齐方式
textView.textAlignment = NSTextAlignment.Right

//文本视图设置圆角
textView.layer.cornerRadius = 20

//是否允许点击链接和附件
textView.selectable = true

//返回键的类型
textView.returnKeyType = UIReturnKeyType.Done

//键盘类型
textView.keyboardType = UIKeyboardType.Default

//是否可以滚动
textView.scrollEnabled = true

//自适应高度
textView.autoresizingMask = UIViewAutoresizing.FlexibleHeight

//富文本不写了

//选中一段文本
//textView.becomeFirstResponder()
//textView.selectedRange = NSMakeRange(5, 10)

//获取内容整体高度
let height = textView.contentSize.height
print(height)
</code></pre><blockquote>
<p>自定义文本视图菜单，就是选中文本，可以复制粘帖那里，可以增加一个分享到微信微博</p>
</blockquote>
<pre><code>//自定义文本视图菜单
var menuItem1 :UIMenuItem = UIMenuItem(title: &quot;分享到微信&quot;, action: &quot;shareWXMenu:&quot;)
var menuItem2 = UIMenuItem(title: &quot;分享到微博&quot;, action: &quot;shareWBMenu:&quot;)
//获取菜单控制器
var menuController = UIMenuController.sharedMenuController()

//重写canPerformAction方法，实现分享
override func canPerformAction(action: Selector, withSender sender: AnyObject?) -&gt; Bool {
    //判断有没有选中文字
    //如果选中，输出选择的文字
    let isSelect:Bool = textView.selectedRange.length &gt; 0

    if (action == &quot;shareWXMenu:&quot; &amp;&amp; isSelect)   //选择文本并点了分享到微信
    {
        return true
    }
    else if(action == &quot;shareWBMenu:&quot; &amp;&amp; isSelect)   //选择文本并点了分享到微博
    {
        return true
    }

    return false    //不显示系统的菜单
}

//分享到微信
func shareWXMenu(sender: AnyObject?)
{
    if textView.selectedRange.length &gt; 0
    {
        print((textView.text as NSString).substringWithRange(textView.selectedRange))
    }
    print(&quot;微信分享&quot;)
}
//分享到微博
func shareWBMenu(sender: AnyObject?)
{
    if textView.selectedRange.length &gt; 0
    {
        print((textView.text as NSString).substringWithRange(textView.selectedRange))
    }
    print(&quot;微博分享&quot;)
}

//菜单控制器，放到viewDidLoad中
menuController.menuItems = [menuItem1,menuItem2]
</code></pre><blockquote>
<p>UITextViewDelegate,所有的UITextViewDelegate都是optional可以选择实现</p>
</blockquote>
<pre><code>//这个特别有用，之前一直不知道该如何把键盘给隐藏
func textView(textView: UITextView, shouldChangeTextInRange range: NSRange, replacementText text: String) -&gt; Bool {
    //文本视图内容改变时，触发本方法，能得到改变的坐标和改变的内容

    //如果是回车符号，则textView释放第一响应值，返回false
    if text == &quot;\n&quot;
    {
        textView.resignFirstResponder()
        return false
    }
    return true
}


func textViewShouldBeginEditing(textView: UITextView) -&gt; Bool {
    return true //如果返回false，文本视图不能编辑
}

func textViewShouldEndEditing(textView: UITextView) -&gt; Bool {
    return true //如果返回false，表示编辑结束之后，文本视图将不能编辑
}

func textViewDidBeginEditing(textView: UITextView) {
    //文本视图开始编辑，这个时候我们可以处理一些事情
    print(&quot;文本视图开始编辑&quot;)
}

func textViewDidEndEditing(textView: UITextView) {
    //文本视图编辑结束，这个时候我嘛可以处理一些事情
}

func textViewDidChange(textView: UITextView) {
    //文本视图改变后触发本代理方法
    print(&quot;文本改变&quot;)
}

func textViewDidChangeSelection(textView: UITextView) {
    //文本视图改变选择内容，触发本代理方法
    print(&quot;文本视图改变选择内容&quot;)
}

func textView(textView: UITextView, shouldInteractWithURL URL: NSURL, inRange characterRange: NSRange) -&gt; Bool {
    //链接在文本中显示，当链接被点击时，会触发本方法
    return true
}

func textView(textView: UITextView, shouldInteractWithTextAttachment textAttachment: NSTextAttachment, inRange characterRange: NSRange) -&gt; Bool {
    //文本视图允许提供文本附件，文本附件点击时，会触发本代理方法
    return true
}
</code></pre><blockquote>
<p>TextView有三个监听</p>
</blockquote>
<pre><code>//创建3个监听，viewDidLoad中
//文本框开始编辑时触发
NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;textDidBeginEditing&quot;, 
name: UITextViewTextDidBeginEditingNotification, object: nil)

//文本框结束编辑时，触发
NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;textDidEndEditing&quot;, 
name: UITextViewTextDidEndEditingNotification, object: nil)

//文本框内容改变时，触发
NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;textDidChange&quot;, 
name: UITextViewTextDidChangeNotification, object: nil)


//实现3个通知事件
func textDidBeginEditing()
{
    print(&quot;开始输入文本&quot;)
}
func textDidEndEditing()
{
    print(&quot;结束输入&quot;)
}
func textDidChange()
{
    print(&quot;正在输入&quot;)
}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/10/05/2015-10-05-UITableView学习-iOS/" itemprop="url">
                  UITableView学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-10-05T00:00:00+08:00" content="2015-10-05">
              2015-10-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>UITableView还真是有点多，一个个代理也还没有全都实现，其中有个按表格跳转还没有实现，还有按表格输出名字不知道莫名其妙的会延迟，就是嗯下一个的时候才输出上一个，还有时候会崩溃，可能上optional没有用好，有一张1033382.jpg图片就不放上来了，随便找一张就ok，在ViewController敲了这么多代码，意识到MVC的重要性了</p>
<p>UITableView显示列表数据，是通过代理实现的，要添加数据源，协议 UITableViewDataSource,UITableViewDelegate</p>
<p>有些代码因为版面的原因看不到，选中即可看到了，或者复制下来</p>
<blockquote>
<p>初始化TableView,定义数组</p>
</blockquote>
<pre><code>//初始化TableView，样式有Plain不分组表视图和Grouped分组表视图
//Plain不分组表视图，如果不设置组间距的话，默认组与组之间没有间距
//Grouped分组表视图,默认组与组之间有一定间距
//var listTableView = UITableView(frame: CGRectMake(0, 20, 470, 600), style: UITableViewStyle.Plain)

var listTableView = UITableView(frame: UIScreen.mainScreen().applicationFrame, style: UITableViewStyle.Plain)

//定义数组
var item:[String] = [
    &quot;UITableView高级使用&quot;,
    &quot;自定义UITableViewCell&quot;,
    &quot;创建分组表&quot;,
    &quot;UITextView&quot;,
    &quot;UISegmentedControl&quot;,
    &quot;UISlider&quot;,
    &quot;UISwitch和UISetpper&quot;,
    &quot;UIActivityIndicatorView&quot;,
    &quot;UIProgressView&quot;,
    &quot;UIAlertView&quot;,
    &quot;UIActionSheet&quot;,
    &quot;UIImageView&quot;,
    &quot;UIScrollView和UIPageControl&quot;,
    &quot;UIWebView&quot;,
    &quot;UIDataPickerView&quot;,
    &quot;UIToolBar和UISearchBar&quot;,
    &quot;UINavigationController&quot;,
    &quot;UITabBarController&quot;,
    &quot;读写应用程序数据&quot;,
    &quot;多点触摸和手势识别&quot;,
    &quot;多媒体应用&quot;,
    &quot;动画&quot;,
    &quot;网络通信&quot;,
    &quot;检测设备朝向和移动&quot;,
    &quot;定位处理与地图&quot;,
    &quot;地址簿，短信，邮件&quot;,
    &quot;iOS应用本地化&quot;
]
</code></pre><blockquote>
<p>必须实现以下四个协议</p>
</blockquote>
<pre><code>//1.设置表视图的节数，也就是分组列表中对应的组，每一组就是一节，在一个分组表中，最开始
的节称为0节，如果TableView只有一节，也可以不用设置此代理方法，系统默认就是一节不分组表视图
//tableView数据源：返回几节（组）
func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int {
    return 1
}

//2.设置表视图的行数，需要返回每一节具有多少行数据，可以根据section值，分别返回不同的条数，代理方法实现代码如下
func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    return item.count   //返回了上面item数组中的数量
}

//3.设置单元格
func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
    //设置单元格UITableViewCell,创建单元格需要注意，一定要先定义一个标示符，指定给cell，这样可以通过这个标示符来获取未使用的cell，实现重用机制
    //创建标示符语句
    let cellIdentifier = &quot;cellIdentifier&quot;

    //可以通过这个常量标示符来获取未使用的cell,有可能获取不到，所以cell为optional
    var cell = tableView.dequeueReusableCellWithIdentifier(cellIdentifier)
    //判断cell是否存在，如果不存在，才需要创建新的cell
    if cell == nil
    {
        //创建新的cell，cell样式UITableViewCellStyle.Default，cell标示符cellIdentifier
        /*UITableViewCellStyle这个有四种样式可选，Default,Subtitle,Value1,Value2,具体样式可以再查Goole*/
        cell = UITableViewCell(style: UITableViewCellStyle.Default, reuseIdentifier: cellIdentifier)

        //设置字体
        cell?.textLabel?.font = UIFont.systemFontOfSize(14)
        //设置选中cell样式
        cell?.selectionStyle = .Gray
        //设置cell后面箭头样式,有5种样式，None,DisclosureIndicator,DetailDisclosureButton,
        //Cherkmark,DetailButton
        cell?.accessoryType = .DisclosureIndicator
    }

    //从数组中取对应值给cell赋值
    cell?.textLabel?.text = item[indexPath.row]
    //设置cell图片
    cell?.imageView?.image = UIImage(named: &quot;1033382.jpg&quot;)
    //因为样式，所以要detailTextLabel
    cell?.detailTextLabel?.text = &quot;详细信息介绍&quot;

    return cell!
}


//4.tableView数据源，每一行高度
func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat {
    //tableView来指定表视图，indexPath来指定哪一节哪一行需要返回的高度，指定表视图的哪一行
    return 50
}
</code></pre><blockquote>
<p>UITableViewCell选择事件,当选择了这个cell会发生什么，这里输出text，可以进行跳转，但是这里有一些小问题，输出text也会崩溃，按当前cell会输出上一个cell的text</p>
</blockquote>
<pre><code>//UITableViewCell选择事件，当在TableView中点击一个cell时，会调用此方法，tableView代表当前触发手势的TableView对象，indexPath参数代表
//当前点击的位置，需要注意一点，当选中一个cell时，应取消前一个cell的选择状态，具体如下
//tableView代理，点击一行，可以不实现
func tableView(tableView: UITableView, didDeselectRowAtIndexPath indexPath: NSIndexPath) {
    //释放选中效果
    tableView.deselectRowAtIndexPath(indexPath, animated: true)

    //获得点击的cell
    let cell:UITableViewCell! = tableView.cellForRowAtIndexPath(indexPath)
    print(cell!.textLabel!.text!)

    //判断cell内容，根据内容不同打开不同界面
    var viewCtrl: UIViewController!
    if cell.textLabel!.text! == &quot;UITableView高级使用&quot;
    {
        let newCtrl = UITableViewController(nibName: &quot;UITableViewControllerAF&quot;, bundle: NSBundle.mainBundle())      //这个有点问题
        newCtrl.title = cell.textLabel!.text!
        viewCtrl = newCtrl
    }

}
</code></pre><blockquote>
<p>实现表视图的编辑操作，必须实现下面三个代理方法</p>
</blockquote>
<pre><code>//1.指定单元格是否具有编辑功能
func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
    return true
}
//2.指定单元格每一行的编辑类型,返回每一行操作类型
func tableView(tableView: UITableView, editingStyleForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCellEditingStyle {
    if indexPath.row == item.count - 1
    {
        return UITableViewCellEditingStyle.Insert//最后一行允许插入
    }
    return UITableViewCellEditingStyle.Delete// 允许删除
    //编辑类型有三种，Insert具有插入功能，Delete具有删除功能，None不具有功能
}
//3.指定单元格是否允许拖动，编辑状态下，是否允许拖动
func tableView(tableView: UITableView, canMoveRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
    return true
}
</code></pre><blockquote>
<p>设置一个编辑／完成按钮，最后三条语句仅仅只是为了测试，要删除</p>
</blockquote>
<pre><code>var button = UIButton(frame: CGRectMake(300, 0, 115, 60))
@IBAction func editButtonClick()
{
    if button.titleForState(UIControlState.Normal) == &quot;编辑&quot;
    {
        //如果按钮标题为编辑，则将表视图设置成可编辑的状态，并修改button标题为完成
        self.listTableView.setEditing(true, animated: true)
        button.setTitle(&quot;完成&quot;, forState: .Normal)
    }
    else
    {
        //如果按钮标题为完成，则将表视图设置成不可编辑，并修改button标题为编辑
        self.listTableView.setEditing(false, animated: true)
        button.setTitle(&quot;编辑&quot;, forState: .Normal)
    }

    //也可以自定义一个按钮来添加新单元格，这里直接用编辑的按钮了
    //数组添加新数据
    item.insert(&quot;新城市\(item.count)&quot;, atIndex: 0)
    //初始化一个NSIndexPath对象，指定要添加单元格位置
    let indexPath = NSIndexPath(forItem: 0, inSection: 0)
    //在指定位置上添加一个新的单元格
    self.listTableView.insertRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic)
}
</code></pre><blockquote>
<p>实现表视图的删除插入操作</p>
</blockquote>
<pre><code>/*UITableViewRowAnimation,Fade单元格淡出,Right单元格从右侧划出,Left单元格从左侧划出,
Top单元格滑动到相邻单元格之上,Bottom单元格滑动到相邻单元格之下,None无动画,Middle始终居中,
Automatic自动效果*/

func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
    //如果是删除操作
    if editingStyle == UITableViewCellEditingStyle.Delete
    {
        //数据源数组删除对应行数 数据,经常忘了这个.row......
        item.removeAtIndex(indexPath.row)
        //table表删除该行,注意[indexPath]
        tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Left)
    }
    else if editingStyle == UITableViewCellEditingStyle.Insert
    {
        //数组添加一条新数据
        item.append(&quot;新城市\(item.count)&quot;)
        //表视图插入一条单元格
        tableView.insertRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Middle)
    }
}
</code></pre><blockquote>
<p>移动cell事件&amp;行缩进，行缩进item.count仅仅只是为了演示</p>
</blockquote>
<pre><code>//移动cell事件，sourceIndexPath: NSIndexPath代表移动初始位置，toIndexPath destinationIndexPath: NSIndexPath代表移动的目标位置
func tableView(tableView: UITableView, moveRowAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath) {
    if sourceIndexPath != destinationIndexPath
    {
        //获取移动行对应的值
        let itemValue = item[sourceIndexPath.row]
        //删除移动行的值
        item.removeAtIndex(sourceIndexPath.row)
        //如果移动区域大于现有行数，直接在最后添加移动的值
        if destinationIndexPath.row &gt; item.count
        {
            item.append(itemValue)
        }
        else
        {
            item.insert(itemValue, atIndex: destinationIndexPath.row)
        }
    }
}

//行缩进
func tableView(tableView: UITableView, indentationLevelForRowAtIndexPath indexPath: NSIndexPath) -&gt; Int {
    //每行按其索引缩进
    return indexPath.row
}
</code></pre><blockquote>
<p>viewDidLoad()中的代码</p>
</blockquote>
<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view, typically from a nib.

    //指定TableView的数据源和代理
    self.listTableView.delegate = self
    self.listTableView.dataSource = self
    self.view.addSubview(listTableView)

    button.backgroundColor = UIColor.orangeColor()
    button.setTitle(&quot;编辑&quot;, forState: .Normal)
    button.addTarget(self, action: &quot;editButtonClick&quot;, forControlEvents: .TouchUpInside)
    self.listTableView.addSubview(button)

}
</code></pre><blockquote>
<p>自定义UITableViewCell，这里也有点小问题，下面的代码是ok的，但是整合到上面的代码，无法用上面的代码来自定义cell，可能要改的地方有点多</p>
</blockquote>
<pre><code>import UIKit

class MyTableViewCell: UITableViewCell {

    var iconImageView:UIImageView!  //图片
    var appNameLabel:UILabel!       //标题
    var decLabel:UILabel!           //描述

    //赋值方法－显示cell内容方法
    func showAppInfoWithModel(model: AppsModel)
    {
        //获取model中的图片
        iconImageView.image = UIImage(named: model.imageName)

        //获取model中app名称
        appNameLabel.text = model.appName

        //获取app描述
        decLabel.text = model.appDescription
    }

    override init(style: UITableViewCellStyle, reuseIdentifier : String?)
    {
        super.init(style: style, reuseIdentifier: reuseIdentifier)

        //创建iconImageView
        iconImageView = UIImageView(frame: CGRectMake(10, 5, 40, 40))
        self.addSubview(iconImageView)

        //创建appNameLabel
        appNameLabel = UILabel(frame: CGRectMake(60, 0, 40, 400))
        appNameLabel.font = UIFont.systemFontOfSize(16)
        self.addSubview(appNameLabel)

        //创建decLabel
        decLabel = UILabel(frame: CGRectMake(60, 15, 220, 35))
        decLabel.font = UIFont.systemFontOfSize(12)
        decLabel.numberOfLines = 2
        decLabel.textColor = UIColor.lightGrayColor()
        self.addSubview(decLabel)

    }

    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }


    override func awakeFromNib() {
        super.awakeFromNib()
        // Initialization code
    }

    override func setSelected(selected: Bool, animated: Bool) {
        super.setSelected(selected, animated: animated)

        // Configure the view for the selected state
    }

}
</code></pre><blockquote>
<p>还需要添加一个NSObject的AppsModel</p>
</blockquote>
<pre><code>import UIKit

class AppsModel: NSObject {
    //定义模型的三个属性
    var imageName:String!  //图片名称
    var appName:String!     //应用名称
    var appDescription:String!      //应用描述



    //自定义初始化方法
    init(imageName image_Name:String , app_Name:String , app_Description:String) {
        self.imageName=image_Name
        self.appName=app_Name
        self.appDescription=app_Description
    }



    // MARK: - NSCoding
    func encodeWithCoder(_encoder: NSCoder)
    {
        _encoder.encodeObject(self.imageName, forKey: &quot;M_imageName&quot;)
        _encoder.encodeObject(self.appName, forKey: &quot;M_appName&quot;)
        _encoder.encodeObject(self.appDescription, forKey: &quot;M_appDescription&quot;)
    }


    init(coder decoder: NSCoder)
    {
        //        imageName = decoder.decodeObjectForKey(&quot;M_imageName&quot;) as String
        //        appName = decoder.decodeObjectForKey(&quot;M_appName&quot;) as String
        //        appDescription = decoder.decodeObjectForKey(&quot;M_appDescription&quot;) as String

        imageName = decoder.decodeObjectForKey(&quot;M_imageName&quot;) as! String
        appName = decoder.decodeObjectForKey(&quot;M_appName&quot;) as! String
        appDescription = decoder.decodeObjectForKey(&quot;M_appDescription&quot;) as! String
    }

}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/10/02/2015-10-02-UIButton学习-iOS/" itemprop="url">
                  UIButton学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-10-02T00:00:00+08:00" content="2015-10-02">
              2015-10-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>UIButton也不是很难，就是设置一下button的标题，或者是图片，按钮的颜色之类的，按下的效果，还有要写一下按钮按下的函数，按下将会发生什么</p>
<blockquote>
<p>初始化</p>
</blockquote>
<pre><code>//初始化
var button = UIButton(frame: CGRectMake(0, 300, 200, 60))

//UIButtonType来初始化，DetailDisclosure蓝色小箭头，InfoDark暗色小箭头，InfoLight亮色小
箭头，ContactAdd十字加号,System系统风格，Custom自定义风格，好像有些要在特点适合地方才能
用，我测试了有几个不能用
var button2 = UIButton(type: UIButtonType.ContactAdd)
</code></pre><blockquote>
<p>按钮状态，颜色，字体，设置图片</p>
</blockquote>
<pre><code>//需要指定状态
button.setTitle(&quot;aaa&quot;, forState: .Normal)
//获取标题标签控件
let label1 = button.titleLabel
print(label1)
//正常状态颜色
button.setTitleColor(UIColor.redColor(), forState: UIControlState.Normal)
//鼠标按下时的颜色
button.setTitleColor(UIColor.blackColor(), forState: .Highlighted)
//设置标题阴影颜色
button.setTitleShadowColor(UIColor.blackColor(), forState: .Normal)
//设置图片,会覆盖标题
//button.setImage(UIImage(named: &quot;testImage.jpg&quot;), forState: .Normal)
</code></pre><blockquote>
<p>富文本，前面两个有富文本的详细，这里不写了</p>
</blockquote>
<pre><code>//设置富文本,富文本的其它看前两个控件
let buttonAttribute = NSMutableAttributedString(string: &quot;1234567890&quot;)
//添加至按钮
button.setAttributedTitle(buttonAttribute, forState: .Normal)
</code></pre><blockquote>
<p>有时候可能按钮可能会深一点，通过这两个方法调整，还有个发光功能，微博有用到</p>
</blockquote>
<pre><code>//默认情况下，按钮高亮的情况下，图像会被画的深一些，如果下面的这个属性设置成false，
可以去掉这个功能
button.adjustsImageWhenHighlighted = false
//默认情况下，当按钮禁用时，图像会被画得深一些，false可以取消
button.adjustsImageWhenDisabled = false
//下面这个属性设置成true，按钮按下会发光,和高亮不同,好像微博里有用到这个
button.showsTouchWhenHighlighted = true
</code></pre><blockquote>
<p>获取按钮的文本，标题，颜色，阴影颜色，图片</p>
</blockquote>
<pre><code>//获取富文本
let attributedTitle = button.attributedTitleForState(.Normal)
//获取标题
let titleOfState = button.titleForState(.Normal)
//获取标题颜色
let titleColorOfState = button.titleColorForState(.Normal)
//获取标题阴影颜色
let titleShadowColorOfState = button.titleShadowColorForState(.Normal)
//获取图片
let imageOfState = button.imageForState(.Normal)
</code></pre><blockquote>
<p>通过这个函数来实现设置方法，当然可以用连线这种更简单的方法，一下这个比较适合用代码来创建一个按钮</p>
</blockquote>
<pre><code>//target一般用self，指实现方法的对象,action后跟一个方法名，注意要加引号，
forControlEvents是枚举事件类型
button.addTarget(target: AnyObject?, action: Selector, forControlEvents: UIControlEvents)
</code></pre><p>如下面这个例子</p>
<pre><code>button.addTarget(self, action: &quot;buttonUpInsideFunc&quot;, forControlEvents: .TouchUpInside)

func buttonUpInsideFunc()
{
    print(&quot;按下了按钮，触摸并抬起&quot;)
}
</code></pre><p>常用的事件类型如下</p>
<p>AllEditingEvents            通知所有关于文本编辑的窗口</p>
<p>AllEvents                        通知所有事件</p>
<p>AllTouchEvents                通知所有触摸事件</p>
<p>ApplicationReserved        保留供应用程序的使用</p>
<p>EditingChanged                当文本控件中的文本被改变时触发</p>
<p>EditingDidBegin                当文本控件中开始编辑时触发</p>
<p>EditingDidEnd                当文本控件中编辑结束时触发</p>
<p>EditingDidEndOnExit        当文本控件内通过按下回车键结束编辑时触发</p>
<p>PrimaryActionTriggered    触发主要事件</p>
<p>SystemReserved                保留供内部框架的使用范围</p>
<p>TouchCancel                    触摸取消事件，即一次触摸因为放上了太多手指而被取消，或接打电话</p>
<p>TouchDown                        单点触摸下事件，点触屏幕</p>
<p>TouchDownRepeat                多点触摸按下事件，点触计数大于1，按下第2，3，4根手指的时候</p>
<p>TouchDragEnter                触摸从控件之外拖动到内部时</p>
<p>TouchDragExit                触摸从控件内部拖动到外部时</p>
<p>TouchDragInside                触摸在控件内拖动时</p>
<p>TouchDragOutside            触摸在控件之外拖动时</p>
<p>TouchUpInside                在控件之内触摸并抬起事件，这个用的最多</p>
<p>TouchUpOutside                在控件之外触摸并抬起事件</p>
<p>ValueChanged                    当控件的值发生变化时，发送通知，用于滑块，分段控件，以及其它取值的控件</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/27/2015-09-27-UITextField学习-iOS/" itemprop="url">
                  UITextField学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-27T00:00:00+08:00" content="2015-09-27">
              2015-09-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>这个也算简单的，只是这些控件需要记住一些方法而已</p>
<blockquote>
<p>代码初始化UITextField控件</p>
</blockquote>
<pre><code>var textField = UITextField(frame: CGRectMake(0, 100, 300, 40))
</code></pre><blockquote>
<p>添加到视图，文本，背景色，背景图片</p>
</blockquote>
<pre><code>textField.backgroundColor = UIColor.redColor()//背景色
self.view.addSubview(textField)//添加到视图上
textField.text = &quot;aaaaa&quot;//添加到视图
var textString = textField.text//获取文本框内容，类型为optional
textField.background = UIImage(named: &quot;testImage&quot;);//设置背景图片
</code></pre><blockquote>
<p>设置富文本</p>
</blockquote>
<pre><code>//设置富文本
let attributesStr = NSMutableAttributedString(string: &quot;0000123456789&quot;)
//文本0开始5个字符字体HaveticaNeue-Bold,16号
attributesStr.addAttribute(NSFontAttributeName, value: UIFont(name: &quot;HaveticaNeue-Bold&quot;, size: 0)!, range: NSMakeRange(0, 4))
//设置字体颜色
attributesStr.addAttribute(NSForegroundColorAttributeName, value: UIColor.redColor(), range: NSMakeRange(4, 2))
//设置文字背景颜色
attributesStr.addAttribute(NSBackgroundColorAttributeName, value: UIColor.greenColor(), range: NSMakeRange(0, 4))
//添加到textField
textField.attributedText = attributesStr
</code></pre><blockquote>
<p>字体，颜色，对齐方式</p>
</blockquote>
<pre><code>textField.font = UIFont.systemFontOfSize(18)//系统默认字体，18号字体
textField.font = UIFont(name: &quot;Helvetica-Bold&quot;, size: 18)//指定字体制定字号
textField.textColor = UIColor.magentaColor()//字体颜色
/*对齐方式，Left左对齐,Center居中,Right右对齐,Justified最后一行自然对齐,Natural默认对齐脚步*/
textField.textAlignment = .Center
</code></pre><blockquote>
<p>其他一些设置</p>
</blockquote>
<pre><code>//文本框样式,四种,None,Line,Bezel,RoundRect
textField.borderStyle = .RoundedRect

//设置富文本占位符
textField.attributedPlaceholder = attributesStr
//设置占位符，当textField没有文字时显示
textField.placeholder = &quot;请输入学校名称&quot;    
textField.minimumFontSize = 10.0//最小字体
textField.adjustsFontSizeToFitWidth = true//文本内容自动适应标签大小，默认false

/*设置删除效果，Never,WhileEditing,UnlessEditing,Always,就是右边那个x的按钮*/
textField.clearButtonMode = .WhileEditing

//返回文本框编辑状态，默认true可以编辑,这个不能set,只能get
textField.editing

//文本框是否可用
textField.enabled = true

//开始输入时，清空文本框原有内容
textField.clearsOnBeginEditing = true

//允许编辑富文本
textField.allowsEditingTextAttributes = true

//创建左视图
let leftView = UIView(frame: CGRectMake(0, 0, 40, 40))
leftView.backgroundColor = UIColor.blackColor()
textField.leftView = leftView

/*设置做视图显示类型,Never,WhileEditing,UnlessEditing,Always*/
textField.leftViewMode = .WhileEditing//左边会出现一个黑框，不明白有什么用

//同理，可以创建右视图
let rightView = UIView(frame: CGRectMake(260, 0, 40, 40))

//成为第一响应者，光标定位到该文本框，一打开视图就直接可以输入
textField.becomeFirstResponder()

//取消光标，释放键盘
textField.resignFirstResponder()

/*首字母是否大小，None不自动大写，Word单词首字母大写，句子首字母大写，所有字母大写*/
textField.autocapitalizationType = .Words
</code></pre><blockquote>
<p>实现UITextFieldDelegate</p>
</blockquote>
<pre><code>func textFieldShouldBeginEditing(textField: UITextField) -&gt; Bool {
    return true //返回false，文本框将不能编辑
}

func textFieldDidBeginEditing(textField: UITextField) {
    //文本框开始编辑，这个时候可以处理一些事情
}

func textFieldShouldEndEditing(textField: UITextField) -&gt; Bool {
    return true //如果返回false，表示编辑结束之后，文本框不可再编辑
}

func textFieldDidEndEditing(textField: UITextField) {
    //文本框结束编辑，触发本事件，这时候可以处理一些事情
}

func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -&gt; Bool {
    //文本框内容改变时，触发本方法，能得到改变的坐标和改变的内容
    return true
}

func textFieldShouldClear(textField: UITextField) -&gt; Bool {
    //文本框清空时触发此事件
    return true
}

func textFieldShouldReturn(textField: UITextField) -&gt; Bool {
    //按键盘换行位置，会触发此方法，一般用于用户回收键盘，或者是提交数据
    return true
}
</code></pre><blockquote>
<p>文本框状态监听</p>
</blockquote>
<p>有三个通知类型</p>
<p>public let UITextFieldTextDidBeginEditingNotification: String</p>
<p>public let UITextFieldTextDidEndEditingNotification: String</p>
<p>public let UITextFieldTextDidChangeNotification: String</p>
<p>创建三个监听，代码如下</p>
<pre><code>//文本框开始编辑时，触发
NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;textDidBeginEditing&quot;, name: UITextFieldTextDidBeginEditingNotification, object: nil)
//文本框编辑结束时，触发
NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;textDidEndEditing&quot;, name: UITextFieldTextDidEndEditingNotification, object: nil)
//文本框内容改变时，触发
NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;textDidChange&quot;, name: UITextFieldTextDidChangeNotification, object: nil)
</code></pre><p>实现3个通知事件，代码如下</p>
<pre><code>func textDidBeginEditing()
{
    print(&quot;开始输入文本&quot;)
}

func textDidEndEditing()
{
    print(&quot;结束输入&quot;)
}

func textDidChange()
{
    print(&quot;正在输入&quot;)
}
</code></pre><blockquote>
<p>还可以设置键盘外观和完成的按钮样式</p>
</blockquote>
<pre><code>//键盘外观
textField.keyboardAppearance = .Dark
textField.keyboardAppearance = .Default
textField.keyboardAppearance = .Light

//完成按钮形式，还有一些其他
textField.returnKeyType = .Go
textField.returnKeyType = .Continue

//键盘类型，还有一些其他
textField.keyboardType = .PhonePad
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/26/2015-09-26-UILabel学习-iOS/" itemprop="url">
                  UILabel学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-26T00:00:00+08:00" content="2015-09-26">
              2015-09-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>代码创建UILabel,可以放在viewDidLoad()中,Label算是这么多控件中最简单的一个了</p>
<blockquote>
<p>初始化</p>
</blockquote>
<pre><code>var nameLabe: UILabel = UILabel(frame: CGRectMake(100, 100, 200, 60))//初始化
nameLabe.backgroundColor = UIColor.redColor()//背景红色
self.view.addSubview(nameLabe)//添加到视图中
</code></pre><blockquote>
<p>tag值</p>
</blockquote>
<pre><code>nameLabe.tag = 68 //设置tag值
nameLabe = self.view.viewWithTag(68) as! UILabel//可以通过tag值获取nameLabel
</code></pre><blockquote>
<p>设置文本，对其方式</p>
</blockquote>
<pre><code>nameLabe.text = &quot;aa&quot;//设置文本
/*对齐方式:Left左对齐,Center居中,Right右对齐,Justified最后一行自然对齐,Natural默认对齐脚本*/
nameLabe.textAlignment = .Right
</code></pre><blockquote>
<p>字体    </p>
</blockquote>
<pre><code>nameLabe.font = UIFont.systemFontOfSize(18)//设置字体，使用系统默认字体，18号字
nameLabe.font = UIFont(name: &quot;Helvetica-Bold&quot;, size: 18)//指定字体
</code></pre><blockquote>
<p>颜色和阴影</p>
</blockquote>
<pre><code>nameLabe.backgroundColor = UIColor.blueColor()
nameLabe.backgroundColor = UIColor(red: 125/255.0, green: 125/255.0, blue: 255/255.0, alpha: 0.5)//通过RGB来设置颜色，alpha透明度

nameLabe.textColor = UIColor.blueColor()//设置文本颜色
nameLabe.shadowColor = UIColor.yellowColor()//设置文本字体阴影
/*设置阴影方向和大小
( 0,-1)上阴影
( 0, 1)下阴影
(-1, 0)左阴影
( 1, 0)右阴影
*/
nameLabe.shadowOffset = CGSizeMake(2, 0)
</code></pre><blockquote>
<p>一些其他设置</p>
</blockquote>
<pre><code>//设置折行方式，换行模式
nameLabe.lineBreakMode = .ByCharWrapping//保留整个字符
nameLabe.lineBreakMode = .ByClipping//简单剪裁，到界为止
nameLabe.lineBreakMode = .ByTruncatingHead//按照...WXYZ显示
nameLabe.lineBreakMode = .ByTruncatingMiddle//按照abcd...显示
nameLabe.lineBreakMode = .ByTruncatingTail//按照ab..yz显示
nameLabe.lineBreakMode = .ByWordWrapping//以空格为界限保留单词，默认

//是否能与用户交互，默认是false
nameLabe.userInteractionEnabled = false

//文本是否可变，默认是false
nameLabe.enabled = false

//文本行数，等于0时没有行数限制
nameLabe.numberOfLines = 1

//最小字体，行数为1时有效，默认0.0
nameLabe.minimumScaleFactor = 10.0

//文本内容自动适应标签大小，默认false
nameLabe.adjustsFontSizeToFitWidth = true

//设置文本高亮
nameLabe.highlighted = true

//设置文本高亮颜色
nameLabe.highlightedTextColor = UIColor.greenColor()
</code></pre><blockquote>
<p>富文本设置</p>
</blockquote>
<pre><code>//富文本设置
let attributeString = NSMutableAttributedString(string: &quot;1234567890123&quot;)

//文本0开始5个字符字体HelveticaNeue-Bold,16号
attributeString.addAttribute(NSFontAttributeName, value: UIFont(name: &quot;HelveticaNeue-Bold&quot;, size: 16)!, range: NSMakeRange(0, 5))

//设置文字颜色,从0开始，3个单位
attributeString.addAttribute(NSForegroundColorAttributeName, value: UIColor.whiteColor(), range: NSMakeRange(0, 3))

//设置文字背景颜色，从3开始，3个单位
attributeString.addAttribute(NSBackgroundColorAttributeName, value: UIColor.greenColor(), range: NSMakeRange(3, 3))

//最后改label
nameLabe.attributedText = attributeString

/*设置文本基线位置，有以下三种，只有文本行数等于1时有效*/
nameLabe.baselineAdjustment = .AlignBaselines//默认值为文本最上端与label中线对齐
nameLabe.baselineAdjustment = .None//文本最底端与label中线对齐
nameLabe.baselineAdjustment = .AlignCenters//文本中线与label中线对齐
</code></pre><blockquote>
<p>UILabel有两个接口专门用来重写，可以自定义label</p>
</blockquote>
<pre><code>func textRectForBounds(bounds: CGRect,limitedToNumberOfLines numberOfLines: Int) -&gt; CGRect

func drawTextInRect(rect: CGRect)
//上面这两个方法不能调用，只适合被UILabel子类重写

func textRectForBounds(bounds: CGRect, limitedToNumberOfLines numberOfLines: Int) -&gt; CGRect
//用来改变UILabel里面文字展示窗口的大小，可以根据文字的多少，来计算窗口的大小

func drawTextInRect(rect: CGRect)
/*在绘图环境实现文字的绘制，这个方法里面已经配置好了绘图环境，使用方法如下
1.直接获得当前绘图上下文。2.接着更改绘图环境设置。3.调用super方法来绘制即可*/
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/24/2015-09-24-fibonacci数列递归的优化-数据结构/" itemprop="url">
                  fibonacci数列递归的优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-24T00:00:00+08:00" content="2015-09-24">
              2015-09-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>fibonacci用递归写效率极低，很多次重复计算，如果计算f(50),到后面计算f(3),f(2)的数量会极其庞大，几乎是指数增长，而且计算结果都一样，这里产生了严重的浪费，开销极大，是整个递归的弱点所在</p>
<pre><code>//普通递归求fabonacci
long long fabonacciBad(int a)   //效率极低
{
    if(a == 0)
        return 0;
    else if (a == 1)
        return 1;
    else
        return fabonacciBad(a - 1) + fabonacciBad(a - 2);
}
</code></pre><p>以上用递归写，尽管很容易理解，但效率极其低下，计算fabonacciBad(50)会花费大约20分钟左右</p>
<pre><code>//迭代求fabonacci
long long f[100];
f[0] = 0;
f[1] = 1;
for (int i = 2; i &lt; n; ++i)
    f[i] = f[i - 1] + f[i - 2];
</code></pre><p>而用一个for循环来写fibonacci则效率会高不少，测任何数据都轻轻松松，但会溢出，这里可以用一个大数模版来弥补</p>
<pre><code>//记忆化递归
long long arr[100];
memset(arr, -1, sizeof(arr));
long long fabonacci(int a)      //优化后的递归，可以和for写的效率差不多
{
    if(arr[a] == -1)
    {
        if(a == 0)
            arr[0] = 0;
        else if(a == 1)
            arr[1] = 1;
        else
            arr[a] = fabonacci(a - 1) + fabonacci(a - 2);
    }
    return arr[a];
}
</code></pre><p>再看这个代码，经过优化的fabonacci递归，我们可以用一个数组arr[100]来记录是否访问过f(n),如果没有访问过f(n)的值为－1，如果访问过，则可以把f(n)的值记录下来放于数组中，避免了重复计算，实现了记忆化，这个的效率和第二个迭代的fabonacci代码差不多，主要的差距在于递归有不断的函数调用，这里消耗了一些时间</p>
<p>记忆化还可以用于dfs等，可以剪枝提高程序运行效率，避免重复计算</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/23/2015-09-23-选择排序，希尔排序，快排的学习-数据结构/" itemprop="url">
                  选择排序，希尔排序，快排的学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-23T00:00:00+08:00" content="2015-09-23">
              2015-09-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>希尔排序能比普通的选择排序和冒泡排序效率更高，但是低于快排，而又低于STL中的sort，不得不说sort做到了极致,选择，冒泡排序时间复杂度为O(n^2)</p>
<blockquote>
<p>维基百科:<br>希尔排序原始的算法实现在最坏的情况下需要进行O(n^2)的比较和交换。V. Pratt的书对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。</p>
<p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
</blockquote>
<pre><code>//
//  选择排序，希尔排序，快排学习.cpp
//  作业1
//
//  Created by Ray on 15/9/22.
//  Copyright © 2015年 Ray. All rights reserved.
//

#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
const int N = 64000;
using namespace std;
void selectionSort(int list[],int n);
void ShellSort(int array[],int n);
void quickSortRecursive(int arr[], int start, int end);
void swap(int *x, int *y);

int main()
{
    int data[N];
    clock_t start,stop;
    double duration = 0.0;
    srand((unsigned int)time(NULL));

    int times = 1;
    while(times--)
    {
        for(int i = 0;i &lt; N; ++i)
            data[i] = rand();

        start = clock();
        quickSortRecursive(data, 0, N-1);
        stop = clock();
        duration = duration + ((double)(stop - start))/CLOCKS_PER_SEC;
   }
   for (int i = 0; i &lt; N; ++i)
   {
        cout &lt;&lt; data[i] &lt;&lt;&quot;\n&quot;;
    }
        cout &lt;&lt; duration&lt;&lt;&quot;\n&quot;;
    return 0;
}
</code></pre><blockquote>
<p>选择排序</p>
</blockquote>
<pre><code>void selectionSort(int list[],int n)//选择排序
{
    int min, t;
    for(int i = 0; i &lt; n - 1; ++i)
    {
        min = i;
        for (int j = i + 1; j &lt; n; ++j)
        {
        if(list[min] &gt; list[j])
            min = j;
        }
        t = list[i];
        list[i] = list[min];
        list[min] = t;
    }
}
</code></pre><blockquote>
<p>希尔排序</p>
</blockquote>
<pre><code>/*希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。*/
void ShellSort(int array[],int n)//希尔排序，是一种选择排序的优化
{
    int i, j, increment;
    int tmp;
    for(increment = n/2;increment &gt; 0;increment /= 2)//增量从n/2到1，每次／2
    {
        for(i = increment; i &lt; n; i++)//i从increment到n-1
        {
            tmp = array[i];//将array[i]的值赋予tmp
            for(j = i;j &gt;= increment; j -= increment)//j从i到increment，每次减increment
            {
            if(tmp &lt; array[j - increment])
                array[j] = array[j-increment];
            else
                break;
        }
        array[j] = tmp;//如果顺序正确就不会交换
        }
    }
}
</code></pre><blockquote>
<p>快速排序</p>
</blockquote>
<pre><code>void swap(int *x, int *y) {
    int t = *x;
    *x = *y;
    *y = t;
}
/*快排就是以数组中间那个数字为准则，采用分治法来把一个序列分成两个，如果小于准则，则放在左边，大于则放在右边，排好了再进行递归*/
void quickSortRecursive(int arr[], int start, int end) {
    if (start &gt;= end)
        return;
    int mid = arr[end];
    int left = start, right = end - 1;
    while (left &lt; right) {
        swap(&amp;arr[left], &amp;arr[right]);
        while (arr[left] &lt; mid &amp;&amp; left &lt; right)
            left++;
        while (arr[right] &gt;= mid &amp;&amp; left &lt; right)
            right--;
    }
    if (arr[left] &gt;= arr[end])
        swap(&amp;arr[left], &amp;arr[end]);
    else
        left++;
    quickSortRecursive(arr, start, left - 1);
    quickSortRecursive(arr, left + 1, end);
}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/09/20/2015-09-20-对于Xcode编辑器的图标-Xcode/" itemprop="url">
                  对于Xcode编辑器的图标
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-09-20T00:00:00+08:00" content="2015-09-20">
              2015-09-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Xcode/" itemprop="url" rel="index">
                    <span itemprop="name">Xcode</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Xcode很多按钮都只有一个图标，而又不告诉你这个按钮是做什么的，之前都不是很清楚，这篇来记一下各个按钮到底都是干什么的</p>
<p>参考：<a href="http://www.cocoachina.com/ios/20141128/10358.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20141128/10358.html</a></p>
<p><img src="http://cxray.github.io/public/images/XcodeDebugArea.jpg" alt="Xcode"></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/headImage.JPG" alt="Ray" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Ray</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Live For The Dream!</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CXRay" target="_blank">
                  <i class="fa fa-github"></i> github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1795459455/" target="_blank">
                  <i class="fa fa-weibo"></i> weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.instagram.com/ray_oooooo/" target="_blank">
                  <i class="fa fa-instagram"></i> instagram
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
