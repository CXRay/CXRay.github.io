<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>


    <meta name="description" content="Live For The Dream!" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description" content="Live For The Dream!">
<meta property="og:type" content="website">
<meta property="og:title" content="Ray">
<meta property="og:url" content="http://cxray.github.io/index.html">
<meta property="og:site_name" content="Ray">
<meta property="og:description" content="Live For The Dream!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ray">
<meta name="twitter:description" content="Live For The Dream!">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> Ray </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Ray</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">subtitle</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/01/26/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-26T21:41:59+08:00" content="2016-01-26">
              2016-01-26
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/01/09/2016-01-09-数据结构最后的无奈-数据结构/" itemprop="url">
                  数据结构最后的无奈
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-01-09T00:00:00+08:00" content="2016-01-09">
              2016-01-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>数据转换</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

//const int MAXSIZE = 1000;
//int stack[MAXSIZE];
//int top=-1;
//
//bool isEmpty()
//{
//    return top &lt; 0;
//}
//
//bool isFull()
//{
//    return top &gt;= MAXSIZE;
//}
//
//void push(int n)
//{
//    if (!isFull())
//    {
//        stack[++top] = n;
//    }
//}
//
//int pop()
//{
//    if (!isEmpty())
//    {
//        return stack[top--];
//    }
//    else
//    {
//        return NULL;
//    }
//}

typedef struct linkStack{
    int num;
    struct linkStack *next;
} *linkStackPointer;

linkStackPointer stack = NULL;

bool isFull()
{
    return false;
}

bool isEmpty()
{
    if(stack != NULL)
        return false;
    else
        return true;
}

void push(int n)
{
    linkStackPointer point = (linkStackPointer)malloc(sizeof(struct linkStack));
    point-&gt;num = n;
    point-&gt;next = stack;
    stack = point;
}

int pop()
{
    if (stack != NULL)
    {
        int n = stack-&gt;num;
        linkStackPointer tmp = (linkStackPointer)malloc(sizeof(struct linkStack));
        tmp = stack;
        stack = stack-&gt;next;
        free(tmp);
        return n;
    }
    else
        return NULL;
}



int main()
{
    int num;
    cin&gt;&gt;num;
    while (num != 0)
    {
        push(num % 2);
        num = num / 2;
    }
    while (!isEmpty())
    {
        cout&lt;&lt;pop();
    }

    return 0;
}
</code></pre><p>有序表归并</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
using namespace std;
ifstream inFile;
ofstream outFile;

/*
int main() {
    inFile.open(&quot;/Users/Ray/Documents/数据结构/机考题目/2-input.txt&quot;);
    outFile.open(&quot;/Users/Ray/Documents/数据结构/机考题目/2-output.txt&quot;);
    int caseN = 0;
    while(true)
    {
        caseN++;
        int n1,n2;
        inFile&gt;&gt;n1;
        if (n1 == -1)
            break;
        //读数据
        int *arr1 = (int *)malloc(sizeof(int)*n1);
        for (int i = 0; i &lt; n1; ++i)
        {
            inFile &gt;&gt; arr1[i];
        }
        inFile &gt;&gt; n2;
        int *arr2 = (int *)malloc(sizeof(int)*n2);
        for (int i = 0; i &lt; n2; ++i)
        {
            inFile &gt;&gt; arr2[i];
        }

        //归并
        int *arr3 = (int *)malloc(sizeof(int)*(n1+n2));
        int a = 0,b = 0, c = 0;//代表指向arr1和arr2和arr3的数据
        while (a &lt; n1 &amp;&amp; b &lt; n2) {
            if (arr1[a] &lt;= arr2[b])
            {
                arr3[c] = arr1[a];
                a++;
            }
            else
            {
                arr3[c] = arr2[b];
                b++;
            }
            c++;
        }
        while (a &lt; n1)
        {
            arr3[c] = arr1[a];
            c++;
            a++;
        }
        while (b &lt; n2)
        {
            arr3[c] = arr2[b];
            c++;
            b++;
        }

        outFile&lt;&lt;&quot;case&quot; &lt;&lt; caseN &lt;&lt;&quot;:&quot;&lt;&lt;n1+n2&lt;&lt;&quot;\n&quot;;
        for (int i = 0; i &lt; n1+n2; i++)
        {
            outFile&lt;&lt;arr3[i]&lt;&lt;&quot; &quot;;
        }
        outFile&lt;&lt;&quot;\n&quot;;

    }

    inFile.close();
    outFile.close();
    return 0;
}
*/

typedef struct list{
    int num;
    struct list *next;
} *listPointer;

listPointer listP1 = NULL,listP2 = NULL,listP3 = NULL;


listPointer readData(int n)
{
    listPointer p = NULL;
    for (int i = 0; i&lt;n; ++i)
    {
        listPointer tmp = (listPointer)malloc(sizeof(struct list));
        inFile&gt;&gt;tmp-&gt;num;
        tmp-&gt;next = p;
        p = tmp;
    }
    return p;
}

void merge()
{
    listPointer p = (listPointer)malloc(sizeof(struct list));
    listP3 = p;
    while (listP1-&gt;next != NULL &amp;&amp; listP2-&gt;next != NULL)
    {
        if (listP1-&gt;num &gt;= listP2-&gt;num)
        {
            p-&gt;next = listP1;
            p = listP1;
            listP1 = listP1-&gt;next;
        }
        if (listP1-&gt;num &lt; listP2-&gt;num)
        {
            p-&gt;next = listP2;
            p = listP2;
            listP2 = listP2-&gt;next;
        }
    }
    if (listP1 != NULL)
        p-&gt;next = listP1;
    if (listP2 != NULL)
        p-&gt;next = listP2;
}

int main()
{
    inFile.open(&quot;/Users/Ray/Documents/数据结构/机考题目/2-input.txt&quot;);
    outFile.open(&quot;/Users/Ray/Documents/数据结构/机考题目/2-output.txt&quot;);
    int caseN = 0;
    while(true)
    {
        caseN++;
        int n1,n2;
        inFile&gt;&gt;n1;
        if (n1 == -1)
            break;
        listP1 = readData(n1);

        inFile &gt;&gt; n2;
        listP2 = readData(n2);

        merge();

        outFile&lt;&lt;&quot;case&quot; &lt;&lt; caseN &lt;&lt;&quot;:&quot;&lt;&lt;n1+n2&lt;&lt;&quot;\n&quot;;
        for (listPointer p = listP3-&gt;next; p != NULL; p = p-&gt;next) {
            outFile&lt;&lt;p-&gt;num&lt;&lt;&quot; &quot;;
        }
        outFile&lt;&lt;&quot;\n&quot;;
    }

    inFile.close();
    outFile.close();
    return 0;

}
</code></pre><p>二叉树层次遍历</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

typedef struct tree
{
    char data;
    struct tree *leftChild,*rightChild;
} *treePointer;

const int MAXSIZE = 1000;
treePointer queue[MAXSIZE];
int front = 0,rear = 0;

bool isEmpty()
{
    return front == rear;
}

bool isFull()
{
    return (rear+1)%MAXSIZE == front;
}

void addQ(treePointer t)//从后面加，rear
{
    if (!isFull()) {
        queue[rear] = t;
        rear = (rear+1)%MAXSIZE;
    }
}

treePointer deleteQ()//从front删
{
    if (!isEmpty())
    {
        treePointer t = queue[front];
        front = (front+1)%MAXSIZE;
        return t;
    }
    else
        return NULL;
}

treePointer creatTree()
{
    treePointer tree;
    char ch;
    cin&gt;&gt;ch;
    if(ch == &apos;#&apos;)
    {
        return NULL;
    }
    else
    {
        tree = (treePointer)malloc(sizeof(struct tree));
        tree-&gt;data = ch;
        tree-&gt;leftChild = creatTree();
        tree-&gt;rightChild = creatTree();
    }
    return tree;
}

void levelOrder(treePointer tree)
{
    addQ(tree);
    treePointer t;
    while (true)
    {
        t = deleteQ();
        if (t == NULL)
            break;

        cout&lt;&lt;t-&gt;data;
        if (t-&gt;leftChild != NULL)
            addQ(t-&gt;leftChild);
        if(t-&gt;rightChild != NULL)
            addQ(t-&gt;rightChild);
    }
}

int main()
{
    treePointer t = creatTree();
    levelOrder(t);
    cout&lt;&lt;&quot;\n&quot;;
    return 0;
}
</code></pre><p>二叉树中序遍历</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int MAXSIZE = 1000;
typedef struct tree
{
    char data;
    struct tree *leftChild,*rightChild;
} *treePointer;

int top = -1;
treePointer stack[MAXSIZE];

bool isEmpty()
{
    return top &lt; 0;
}

bool isFull()
{
    return top &gt;= MAXSIZE - 1;
}

void push(treePointer tree)
{
    if(!isFull())
    {
        stack[++top] = tree;
    }
}

treePointer pop()
{
    if(!isEmpty())
    {
        return stack[top--];
    }
    else
    {
        return NULL;
    }
}

treePointer creatTree()
{
    treePointer t;
    char ch;
    cin &gt;&gt; ch;
    if (ch == &apos;#&apos;)
    {
        return NULL;
    }
    else
    {
        t = (treePointer)malloc(sizeof(struct tree));
        t-&gt;data = ch;
        t-&gt;leftChild = creatTree();
        t-&gt;rightChild = creatTree();
    }
    return t;
}

void iterInorder(treePointer tree)
{
    treePointer node = tree;
    while (true)
    {
        for (; node; node = node-&gt;leftChild)
        {
            push(node);
        }

        node = pop();
        if (node == NULL)
            break;

        cout &lt;&lt; node-&gt;data;
        node = node-&gt;rightChild;
    }
}

int main()
{
    treePointer t = creatTree();
    iterInorder(t);
    cout&lt;&lt;&quot;\n&quot;;
    return 0;
}
</code></pre><p>广度优先搜索</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

typedef struct node
{
    int num;    //节点编号
    int data;   //权值
    struct node *next;
} *nodePointer;
const int MAXSIZE = 1000;
int n = 0,lines = 0;    //n个节点

nodePointer graph[MAXSIZE];     //图
bool visited[MAXSIZE];

//队列
int queue[MAXSIZE];
int rear = 0,front = 0;
bool isEmpty()
{
    return rear == front;
}
bool isFull()
{
    return (rear+1)%MAXSIZE == front;
}
void addQ(int node)
{
    if(!isFull())
    {
        queue[rear] = node;
        rear = (rear+1)%MAXSIZE;
    }
}
int deleteQ()
{
    if(!isEmpty())
    {
        int n = queue[front];
        front = (front+1)%MAXSIZE;
        return n;
    }
    else
        return NULL;
}

void creatGraph()
{
    cin &gt;&gt; n &gt;&gt; lines;

    for(int i = 0;i &lt; n;++i)
    {
        graph[i] = (nodePointer) malloc(sizeof(struct node));
    }

    for (int i = 0; i &lt; lines; ++i)
    {
        int a,b,data;       //起始点，终点，权值
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;data;
        nodePointer p = (nodePointer)malloc(sizeof(struct node));
        p-&gt;data = data;
        p-&gt;num = b;
        p-&gt;next = graph[a]-&gt;next;
        graph[a]-&gt;next = p;
    }

}

void setVisitedFalse()
{
    for (int i = 0; i &lt; MAXSIZE; ++i)
        visited[i] = false;
}

void bfs(int v)
{
    nodePointer point;
    cout&lt;&lt;v&lt;&lt;&quot; &quot;;
    visited[v] = true;
    addQ(v);
    while (!isEmpty())
    {
        v = deleteQ();
        for (point = graph[v]-&gt;next; point != NULL; point = point-&gt;next)
        {
            if(!visited[point-&gt;num])
            {
                cout&lt;&lt;point-&gt;num&lt;&lt;&quot; &quot;;
                addQ(point-&gt;num);
                visited[point-&gt;num] = true;
            }
        }
    }
}

int main()
{
    creatGraph();
    setVisitedFalse();
    bfs(1);
    cout&lt;&lt;&quot;\n&quot;;
    return 0;
}
</code></pre><p>深度优先搜索</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

typedef struct node
{
    int num;        //节点
    int data;       //权值
    struct node *next;
} *nodePointer;

const int MAXSIZE = 1000;
int n = 0,lines = 0;//节点，线
nodePointer graph[MAXSIZE];
bool visited[MAXSIZE];

void setVisitedFalse()
{
    for(int i = 0;i &lt; MAXSIZE; ++i)
        visited[i] = false;
}

void creatGraph()
{
    cin&gt;&gt;n&gt;&gt;lines;
    for(int i = 0;i &lt; n;++i)
    {
        graph[i] = (nodePointer)malloc(sizeof(struct node));
    }

    for (int i = 0; i &lt; lines; ++i)
    {
        int a,b,data;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;data;
        nodePointer point = (nodePointer)malloc(sizeof(struct node));
        point-&gt;num = b;
        point-&gt;data = data;
        point-&gt;next = graph[a]-&gt;next;
        graph[a]-&gt;next = point;
    }

}

void dfs(int v)
{
    cout&lt;&lt;v&lt;&lt;&quot; &quot;;
    visited[v] = true;
    nodePointer point;
    for (point = graph[v]-&gt;next; point != NULL; point = point-&gt;next)
    {
        if (!visited[point-&gt;num])
        {
            dfs(point-&gt;num);
        }
    }
}

int main()
{
    creatGraph();
    dfs(3);
    cout&lt;&lt;&quot;\n&quot;;
    return 0;
}
</code></pre><p>堆排序</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
using namespace std;

//void swap(int *x, int *y) {
//    int t = *x;
//    *x = *y;
//    *y = t;
//}

void maxHeapify(int arr[],int start,int end)
{
    int dad = start;
    int son = dad *2 +1;
    while (son &lt; end)
    {
        if(son+1 &lt; end &amp;&amp; arr[son] &lt; arr[son+1])
        {
            son++;
        }
        if(arr[dad]&gt;arr[son])//调整完成
            return;
        else
        {
            swap(arr[dad], arr[son]);
            dad = son;
            son = dad*2+1;
        }
    }
}

void heapSort(int arr[],int length)
{
    for (int i = length/2; i&gt;=0; i--)
    {
        maxHeapify(arr, i, length);
    }
    for (int i = length-1; i&gt;0; i--)
    {
        swap(arr[0], arr[i]);
        maxHeapify(arr, 0, i);
    }
}

int main()
{
    ifstream inFile;
    ofstream outFile;
    inFile.open(&quot;/Users/Ray/Documents/数据结构/机考题目/input.txt&quot;);
    outFile.open(&quot;/Users/Ray/Documents/数据结构/机考题目/output.txt&quot;);

    int count = 1;
    int arr[100];
    int len;
    inFile &gt;&gt; len;
    while (len != -1)
    {
        for (int i = 0; i&lt;len; i++)
            inFile&gt;&gt;arr[i];
        heapSort(arr, len);


        outFile&lt;&lt;&quot;Case &quot;&lt;&lt;count&lt;&lt;&quot;:&quot;&lt;&lt;len&lt;&lt;&quot;\n&quot;;
        for (int i = 0; i &lt; len; ++i)
            outFile&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;

        outFile&lt;&lt;&quot;\n&quot;;
        inFile&gt;&gt;len;
        count++;
    }
    return 0;
}
</code></pre><p>快排</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
using namespace std;

void quickSort(int arr[],int start,int end)
{
    if(start &gt;= end)
        return;

    int mid = arr[end];
    int left = start,right = end-1;

    while (left &lt; right)
    {
        while (arr[left] &lt; mid &amp;&amp; left &lt; right)
            left++;
        while (arr[right] &gt;= mid &amp;&amp; left &lt; right)
            right--;
        swap(arr[left], arr[right]);
    }

    if (arr[left] &gt;= arr[end])
        swap(arr[left], arr[end]);
    else
        left++;

    quickSort(arr, start, left-1);
    quickSort(arr, left+1, end);
}

int main()
{
    ifstream inFile;
    ofstream outFile;
    inFile.open(&quot;/Users/Ray/Documents/数据结构/机考题目/input.txt&quot;);
    outFile.open(&quot;/Users/Ray/Documents/数据结构/机考题目/output.txt&quot;);

    int count = 1;
    int arr[100];
    int len;

    inFile&gt;&gt;len;
    while (len != -1)
    {
        for (int i = 0; i&lt;len; ++i)
            inFile &gt;&gt; arr[i];

        quickSort(arr, 0, len-1);

        outFile &lt;&lt; &quot;Case &quot; &lt;&lt; count &lt;&lt; &quot;:&quot; &lt;&lt; len &lt;&lt;&quot;\n&quot;;
        for (int i = 0; i &lt; len; ++i)
        {
            outFile &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
        }
        outFile &lt;&lt; &quot;\n&quot;;
        inFile &gt;&gt; len;
        count++;
    }
    return 0;
}

//void swap(int *x, int *y) {
//    int t = *x;
//    *x = *y;
//    *y = t;
//}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/12/26/2015-12-26-You游校园导航项目总结-iOS/" itemprop="url">
                  关于You游服务外包项目的总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-12-26T00:00:00+08:00" content="2015-12-26">
              2015-12-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>项目具体文件我放到GitHub上了，<a href="https://github.com/CXRay/You-" target="_blank" rel="external">https://github.com/CXRay/You-</a></p>
<p>总得来说这是我iOS实际上第一个完整的项目吧，iOS学了好长一段时间了，做完这个项目，OC也懂了大半，之前只会用Swift来着。</p>
<p>下面贴几个比较重要的代码吧</p>
<p>界面跳转，使用storyboard的Identifier进行跳转和使用AlertController进行弹窗警告</p>
<pre><code>AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;
app.isStartNavi = NO;

UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;已结束导航&quot; message:@&quot;是否需要志愿者&quot; preferredStyle:UIAlertControllerStyleAlert];
UIAlertAction *action = [UIAlertAction actionWithTitle:@&quot;是&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {

    UIStoryboard *mainStoryboard = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];
    NearbyViewController *nextController = [mainStoryboard instantiateViewControllerWithIdentifier:@&quot;VolunteerTableView&quot;];
    [self.navigationController pushViewController:nextController animated:YES];
}];

UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;否&quot; style:UIAlertActionStyleDestructive handler:nil];
[alert addAction:action];
[alert addAction:cancel];
[self presentViewController:alert animated:YES completion:nil];
</code></pre><p>在地图上添加标注，不过这个是高德地图</p>
<pre><code>-(MAAnnotationView *)mapView:(MAMapView *)mapView viewForAnnotation:(id&lt;MAAnnotation&gt;)annotation
{
    if ([annotation isKindOfClass:[MAPointAnnotation class]])
    {
        static NSString *pointReuseIndentifier = @&quot;pointReuseIndentifier&quot;;
        CustomAnnotationView *annotationView = (CustomAnnotationView*)[mapView dequeueReusableAnnotationViewWithIdentifier:pointReuseIndentifier];
        if (annotationView == nil) {
            annotationView = [[CustomAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:pointReuseIndentifier];
        }
        num++;
        if(num &lt;= 53)
        {
            annotationView.image = [UIImage imageNamed:@&quot;Marker&quot;];//设置图片
        }
        else if(num &gt;= 54 &amp;&amp; num &lt;= 58)
        {
            annotationView.image = [UIImage imageNamed:@&quot;Marker2&quot;];
        }
        else
        {
            num = num % 58;
        }
        //NSLog(@&quot;%d\n&quot;,num);
        annotationView.centerOffset = CGPointMake(0, -18);//设置图片偏移量
        return annotationView;
    }
    return nil;
}
</code></pre><p>通过AppDelegate.h传送数据，不过这个写法并不好，以后改进，要用到数据存储</p>
<pre><code>AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;
app.isStartNavi = NO;
</code></pre><p>搜索栏的实现，不过这个方法已经被iOS9废弃，以后改</p>
<pre><code>NSMutableArray *data;
NSMutableArray *filterData;
UISearchDisplayController *searchDisplayController;
UISearchBar *searchBar;


searchBar = [[UISearchBar alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width , 44)];
searchBar.placeholder = @&quot;搜索&quot;;

// 添加 searchbar 到 headerview
self.tableView.tableHeaderView = searchBar;

// 用 searchbar 初始化 SearchDisplayController
// 并把 searchDisplayController 和当前 controller 关联起来
searchDisplayController = [[UISearchDisplayController alloc] initWithSearchBar:searchBar contentsController:self];

// searchResultsDataSource 就是 UITableViewDataSource
searchDisplayController.searchResultsDataSource = self;
// searchResultsDelegate 就是 UITableViewDelegate
searchDisplayController.searchResultsDelegate = self;

data = [[NSMutableArray alloc]init];
for (int i = 0; i &lt; 53; ++i) {
    [data addObject:buildingsIn[i].titleForLocation];
}

[searchBar becomeFirstResponder];
</code></pre><p>点击图片换从相册换图，这个不要用手势，直接用Button，后来才想明白的，要UIImagePickerControllerDelegate</p>
<pre><code>- (IBAction)tapCardImage:(UITapGestureRecognizer *)sender {
    [self tapBackground:nil];
    imageSrc = @&quot;cardImage&quot;;
    UIImagePickerController *imagePickerController = [[UIImagePickerController alloc]init];
    imagePickerController.delegate = self;
    imagePickerController.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
    [self presentViewController:imagePickerController animated:YES completion:nil];
}
</code></pre><p>自定义TableView记得写identifier，而且tableView中有个imageView属性，所以也要避开这个坑</p>
<pre><code>-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;
    static NSString *recommendTableIdentifier = @&quot;RecommendTableIdentifier&quot;;
    MyRecommendTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:recommendTableIdentifier];

    if (cell == nil) {
        cell = [[MyRecommendTableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:recommendTableIdentifier];
    }

    cell.imageView2.image = app.images[indexPath.row];
    cell.labelForKind.text = app.kind[indexPath.row];
    cell.labelForDetail.text = app.detail[indexPath.row];

    [cell.imageView2.layer setMasksToBounds:YES];
    [cell.imageView2.layer setCornerRadius:10.0];


    return cell;
}
</code></pre><p>TableView取消选中状态，如果没有这个，点个tableView会很丑</p>
<pre><code>-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    [self.tableView deselectRowAtIndexPath:indexPath animated:true];
}
</code></pre><p>实现打电话和延时弹出窗口</p>
<pre><code>-(void)btnTap
{
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;是否呼叫志愿者&quot; message:nil preferredStyle:UIAlertControllerStyleAlert];
    UIAlertAction *action = [UIAlertAction actionWithTitle:@&quot;是&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        NSURL *URL = [NSURL URLWithString:[NSString stringWithFormat:@&quot;tel://123456789&quot;]];
        [[UIApplication sharedApplication] openURL:URL];

        //延时执行
        [self performSelector:@selector(evaluateVolunteer) withObject:nil afterDelay:3];
    }];

    UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;否&quot; style:UIAlertActionStyleDestructive handler:nil];
    [alert addAction:action];
    [alert addAction:cancel];
    [self presentViewController:alert animated:YES completion:nil];
}

-(void)evaluateVolunteer
{
    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;是否预约成功&quot; message:nil preferredStyle:UIAlertControllerStyleAlert];
    UIAlertAction *action = [UIAlertAction actionWithTitle:@&quot;是&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
        //呼叫成功要做什么
    }];
    UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;否&quot; style:UIAlertActionStyleDestructive handler:nil];
    [alert addAction:action];
    [alert addAction:cancel];
    [self presentViewController:alert animated:YES completion:nil];
}
</code></pre><p>控件加圆角属性，加边框，带到第一层</p>
<pre><code>[_callVolunteerBtn.layer setMasksToBounds:YES];
//按钮加边框
_callVolunteerBtn.layer.borderWidth = 1.5;
//按钮加圆角
[_callVolunteerBtn.layer setCornerRadius:10.0];
[self.view bringSubviewToFront:_callVolunteerBtn];
</code></pre><p>ActionView加TextField</p>
<pre><code>UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;请输入充值金额&quot; message:nil preferredStyle: UIAlertControllerStyleAlert];

UIAlertAction *action = [UIAlertAction actionWithTitle:@&quot;是&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
    money += addMoney;
    _moneyLabel.text = [NSString stringWithFormat:@&quot;%d&quot;, money];
}];

UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;否&quot; style:UIAlertActionStyleDestructive handler:nil];

[alert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {
    textField.placeholder = @&quot;充值金额&quot;;
    textField.keyboardType = UIKeyboardTypeNumberPad;
    [textField addTarget:self action:@selector(addMoneyTextField:) forControlEvents:UIControlEventEditingChanged];
}];
action.enabled = NO;
[alert addAction:action];
[alert addAction:cancel];
[self presentViewController:alert animated:YES completion:nil];
</code></pre><p>跳过登陆界面直接打开主界面，这个用于登陆</p>
<pre><code>NSString *userName = [[NSUserDefaults standardUserDefaults]stringForKey:@&quot;user_name&quot;];
//[[NSUserDefaults standardUserDefaults] synchronize];
if (userName != nil) {
    UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];
    UIViewController *main = [storyBoard instantiateViewControllerWithIdentifier:@&quot;MainViewController&quot;];
    UINavigationController *mainNav =[[UINavigationController alloc]initWithRootViewController:main];
    self.window.rootViewController = mainNav;

}
</code></pre><p>这里要防止主进程堵塞，老师的建议是使用AFNetworking</p>
<pre><code>PFFile *ImageFile = [[PFUser currentUser] objectForKey:@&quot;picture&quot;];

[ImageFile getDataInBackgroundWithBlock:^(NSData * _Nullable data, NSError * _Nullable error) {
    if (!error) {
        [self.touxiang setImage:[UIImage imageWithData:data]];
    }
    else
    {
        [self.touxiang setImage:[UIImage imageNamed:@&quot;1&quot;]];
    }
}];
</code></pre><p>还有一点就是要多用xib文件，一个人编写app的话storyboard比较方便，但多人合作，还是使用xib吧，这个我还没学过，试着写写吧</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/11/21/2015-11-21-逆波兰式转换和计算-Swift/" itemprop="url">
                  逆波兰式转换和计算
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-11-21T00:00:00+08:00" content="2015-11-21">
              2015-11-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>普通的式子例如1+2*3对于人是很容易计算的，但对于电脑很难计算，先要转换成逆波兰式，逆波兰式相对于机器就很容易了，以下算法是用swift实现</p>
<p>　(1)首先，需要分配2个栈，栈s1用于临时存储运算符（含一个结束符号），此运算符在栈内遵循越往栈顶优先级越高的原则；栈s2用于输入逆波兰式，为方便起见，栈s1需先放入一个优先级最低的运算符，在这里假定为’#’；</p>
<p>　　(2)从中缀式的左端开始逐个读取字符x，逐序进行如下步骤：</p>
<p>　　　　　　1.若x是操作数，则分析出完整的运算数（在这里为方便，用字母代替数字），将x直接压入栈s2；</p>
<p>　　　　　　2.若x是运算符，则分情况讨论：</p>
<p>　　　　　　　　　　若x是’(‘，则直接压入栈s1；</p>
<p>　　　　　　　　　　若x是’)’，则将距离栈s1栈顶的最近的’(‘之间的运算符，逐个出栈，依次压入栈s2，此时抛弃’(‘；</p>
<p>　　　　　　　　　　若x是除’(‘和’)’外的运算符，则再分如下情况讨论：</p>
<p>　　　　　　　　　　　　　　若当前栈s1的栈顶元素为’(‘，则将x直接压入栈s1；</p>
<p>　　　　　　　　　　　　　　若当前栈s1的栈顶元素不为’(‘，则将x与栈s1的栈顶元素比较，若x的优先级大于栈s1栈顶运算符优先级，则将x直接压入栈s1。否者，将栈s1的栈顶运算符弹出，压入栈s2中，直到栈s1的栈顶运算符优先级别低于（不包括等于）x的优先级，或栈s2的栈顶运算符为’(‘，此时再则将x压入栈s1;</p>
<p>　　(3)在进行完(2)后，检查栈s1是否为空，若不为空，则将栈中元素依次弹出并压入栈s2中（不包括’#’）；　　　　　　 </p>
<p>　　</p>
<p>　　(4)完成上述步骤后，栈s2便为逆波兰式输出结果。但是栈s2应做一下逆序处理，因为此时表达式的首字符位于栈底；</p>
<pre><code>import Foundation



class Stack {
    var array = [String]()
    var top = -1

    func isEmpty() -&gt; Bool
    {
        return top &lt;= -1
    }

    func isFull() -&gt; Bool
    {
        return false
    }

    func push(ch: String)
    {
        if(!isFull())
        {
            ++top
            array.append(ch)
        }
    }

    func pop() -&gt; String?
    {
        if(!isEmpty())
        {
            let n = array[top]
            top--
            array.removeLast()
            return n
        }
        else
        {
            return nil
        }
    }
    func toppp() -&gt; String?
    {
        if(!isEmpty())
        {
            return array[top]
        }
        else
        {
            return nil
        }
    }


}

var stack1 = Stack()
var stack2 = Stack()
var stack3 = Stack()//存放逆波兰式
var stack4 = Stack()//用于存放最终的值
var length = 0

func RPExpression(aString:String) -&gt; String
{
    //设字符“＃”是运算级最低的运算符，并压入s1中
    stack1.push(&quot;#&quot;);

    var num = &quot;&quot;
    for ch in aString.characters
    {
        if (ch == &quot;(&quot;)
        {
            stack2.push(num)
            num = &quot;&quot;

            stack1.push(&quot;(&quot;)
        }
        else if (ch == &quot;)&quot;)
        {
            stack2.push(num)
            num = &quot;&quot;

            while(stack1.toppp() != &quot;(&quot; &amp;&amp; stack1.toppp() != &quot;#&quot;)
            {
                let a = stack1.pop()
                stack2.push(a!)
            }
            stack1.pop()
        }
        else if (ch == &quot;+&quot; || ch == &quot;-&quot;)
        {
            stack2.push(num)
            num = &quot;&quot;

            if(stack1.isEmpty())
            {
                stack1.push(&quot;\(ch)&quot;)
            }
            else
            {
                for(var top = stack1.toppp();top != &quot;#&quot;;top = stack1.toppp())
                {
                    if(top == &quot;(&quot;)
                    {
                        break
                    }
                    else
                    {
                        let a = stack1.pop()
                        stack2.push(a!)
                    }
                }
                stack1.push(&quot;\(ch)&quot;)

            }
            length++
        }
        else if (ch == &quot;*&quot; || ch == &quot;/&quot;)
        {
            stack2.push(num)
            num = &quot;&quot;

            if(stack1.isEmpty())
            {
                stack1.push(&quot;\(ch)&quot;)
            }
            else
            {
                for(var top = stack1.toppp();top != &quot;#&quot; &amp;&amp; top != &quot;+&quot; &amp;&amp; top != &quot;-&quot;;top = stack1.toppp())
                {
                    if (top == &quot;(&quot;)
                    {
                        break
                    }
                    else
                    {
                        let a = stack1.pop()
                        stack2.push(a!)
                    }
                }
                stack1.push(&quot;\(ch)&quot;)

            }
            length++
        }
        else if (ch == &quot;=&quot;)
        {
            stack2.push(num)
            num = &quot;&quot;
        }
        else
        {
            num += &quot;\(ch)&quot;;
        }
    }

    var ans = &quot;&quot;
    while (!stack1.isEmpty() &amp;&amp; stack1.toppp() != &quot;#&quot;)
    {
        let a = stack1.pop()
        stack2.push(a!)
    }

    //stack2中存储了逆波兰数
//    while(!stack2.isEmpty())
//    {
//        ans = stack2.pop()! + ans
//    }
//    
//    print(ans)

    while(!stack2.isEmpty())
    {
        if let a = stack2.pop()
        {
            if a != &quot;&quot;
            {
                print(a)
                stack3.push(a)
            }
        }
    }


    //下面是逆波兰式的求值
    while(!stack3.isEmpty())
    {
        let a = stack3.pop()        //操作数或操作符
        //print(a)
        if a == &quot;+&quot; || a == &quot;-&quot; || a == &quot;*&quot; || a == &quot;/&quot;
        {
            if a == &quot;+&quot;
            {
                let num1 = Double(stack4.pop()!)!
                let num2 = Double(stack4.pop()!)!
                stack4.push(&quot;\(num2+num1)&quot;)
            }
            else if a == &quot;-&quot;
            {
                let num1 = Double(stack4.pop()!)
                let num2 = Double(stack4.pop()!)
                stack4.push(&quot;\(num2!-num1!)&quot;)
            }
            else if a == &quot;*&quot;
            {
                let num1 = Double(stack4.pop()!)
                let num2 = Double(stack4.pop()!)
                stack4.push(&quot;\(num2!*num1!)&quot;)
            }
            else if a == &quot;/&quot;
            {
                let num1 = Double(stack4.pop()!)
                let num2 = Double(stack4.pop()!)
                stack4.push(&quot;\(num2!/num1!)&quot;)
            }
        }
        else
        {
            stack4.push(a!)
        }
    }


    ans = stack4.pop()!
    print(ans)
    return ans
}

RPExpression(&quot;(1+2)*3/(4+5)=&quot;)
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/11/21/2015-11-21-树的一些简单函数-数据结构/" itemprop="url">
                  树的一些简单函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-11-21T00:00:00+08:00" content="2015-11-21">
              2015-11-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>先实现栈和队列，c++不用实现，直接有STL，但这里实现一下</p>
</blockquote>
<pre><code>treePointer stack[MAXSIZE];    //栈
treePointer queue[MAXSIZE];    //队列
int top = -1;           //栈顶指针
int front = 0,rear = 0; //队列头尾指针
bool isFullStack();
bool isEmptyStack();
void pushStack(treePointer t);
treePointer popStack();
bool isFullQueue();
bool isEmptyQueue();
void addQueue(treePointer t);
treePointer deleteQueue();
</code></pre><blockquote>
<p>栈</p>
</blockquote>
<pre><code>bool isFullStack()
{
    return top &gt;= MAXSIZE - 1;
}

bool isEmptyStack()
{
    return top &lt; 0;
}

void pushStack(treePointer t)
{
    if (!isFullStack())
    {
        stack[++top] = t;
    }
}

treePointer popStack()
{
    if (!isEmptyStack()) {
        return stack[top--];
    }
    return NULL;
}
</code></pre><blockquote>
<p>循环队列</p>
</blockquote>
<pre><code>bool isFullQueue()
{
    return (rear + 1) % MAXSIZE == front;
}

bool isEmptyQueue()
{
    return front == rear;
}

void addQueue(treePointer t)
{
    if (!isFullQueue())
    {
        queue[rear++] = t;
    }
}

treePointer deleteQueue()
{
    if (!isEmptyQueue())
    {
        return queue[front++];
    }
    else
        return NULL;
}
</code></pre><blockquote>
<p>树前面的定义</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAXSIZE = 1000;
typedef struct tree
{
    char data;
    struct tree *leftChild, *rightChild;
} *treePointer;

treePointer creatTree();
void inOrder(treePointer tree);            //递归中序遍历
void preOrder(treePointer tree);          //递归前序遍历
void postOrder(treePointer tree);           //递归后续遍历
void iterInorder(treePointer tree);         //迭代中序遍历
void levelOrder(treePointer tree);         //层序遍历
int leaf(treePointer tree);                 //叶子数
int height(treePointer tree);               //高度

int count(treePointer tree);            //计算节点数
int equal1(treePointer tree);           //计算节点度数为大于1的个数
int equal2(treePointer tree);           //计算节点度数为2的个数
treePointer copy(treePointer tree);     //复制二叉树
</code></pre><blockquote>
<p>创建树</p>
</blockquote>
<pre><code>treePointer creatTree()
{
    treePointer t;
    char ch;
    cin &gt;&gt; ch;
    if (ch == &apos;#&apos;)
    {
        return NULL;
    }
    else
    {
        t = (struct tree *)malloc(sizeof(struct tree));
        t -&gt; data = ch;
        t -&gt; leftChild = creatTree();
        t -&gt; rightChild = creatTree();
    }
    return t;
}
</code></pre><blockquote>
<p>递归中序遍历</p>
</blockquote>
<pre><code>void inOrder(treePointer tree)            //inOrder中序遍历
{
    if (tree == NULL)
    {
        return;
    }
    inOrder(tree -&gt; leftChild);
    cout &lt;&lt; tree -&gt; data;
    inOrder(tree -&gt; rightChild);
}
</code></pre><blockquote>
<p>递归前序遍历</p>
</blockquote>
<pre><code>void preOrder(treePointer tree)           //preOrder前序遍历
{
    if (tree == NULL)
    {
        return;
    }
    cout &lt;&lt; tree -&gt; data;
    preOrder(tree -&gt; leftChild);
    preOrder(tree -&gt; rightChild);
}
</code></pre><blockquote>
<p>递归后续遍历</p>
</blockquote>
<pre><code>void postOrder(treePointer tree)           //postOrder后续遍历
{
    if (tree == NULL)
    {
        return;
    }
    postOrder(tree -&gt; leftChild);
    postOrder(tree -&gt; rightChild);
    cout &lt;&lt; tree -&gt; data;
}
</code></pre><blockquote>
<p>迭代中序遍历</p>
</blockquote>
<pre><code>void iterInorder(treePointer tree)         //迭代中序遍历
{
    treePointer node = tree;
    while (true)
    {
        for (; node; node = node -&gt; leftChild)
        {
            pushStack(node);
        }
        node = popStack();
        if (node == NULL) {
            break;
        }
        cout &lt;&lt; node -&gt; data;
        node = node -&gt; rightChild;
    }
}
</code></pre><blockquote>
<p>层序遍历</p>
</blockquote>
<pre><code>void levelOrder(treePointer tree)           //层序遍历
{
    addQueue(tree);
    treePointer t;
    while (true)
    {
        t = deleteQueue();
        if (t == NULL)
            break;
        cout &lt;&lt; t -&gt; data;
        if (t -&gt; leftChild != NULL)
            addQueue(t -&gt; leftChild);
        if (t -&gt; rightChild != NULL)
            addQueue(t -&gt; rightChild);
    }
}
</code></pre><blockquote>
<p>叶子数</p>
</blockquote>
<pre><code>int leaf(treePointer tree)                 //叶子数
{
    if (tree == NULL)
    {
        return 0;
    }

    if (tree -&gt; leftChild == NULL &amp;&amp; tree -&gt; rightChild == NULL)
    {
        return 1;
    }
    return leaf(tree -&gt; leftChild) + leaf(tree -&gt; rightChild);

}
</code></pre><blockquote>
<p>高度</p>
</blockquote>
<pre><code>int height(treePointer tree)               //高度
{
    int leftHeight = 0,rightHeight = 0;
    if (tree == NULL)
    {
        return 0;
    }
    else
    {
        leftHeight = height(tree -&gt; leftChild) + 1;
        rightHeight = height(tree -&gt; rightChild) + 1;
        return max(leftHeight, rightHeight);
    }
}
</code></pre><blockquote>
<p>计算节点数</p>
</blockquote>
<pre><code>int count(treePointer tree)             //计算节点个数
{
    if (tree == NULL)
        return 0;
    else
        return count(tree -&gt; leftChild) + count(tree -&gt; rightChild) + 1;
}
</code></pre><blockquote>
<p>计算节点度数为大于1的个数</p>
</blockquote>
<pre><code>int equal1(treePointer tree)            //计算节点度数为大与1的个数
{
    if (tree == NULL) {
        return 0;
    }
    if (tree-&gt;leftChild != NULL || tree-&gt;rightChild != NULL)
        return equal1(tree-&gt;leftChild) + equal1(tree-&gt;rightChild) + 1;
    return equal1(tree-&gt;leftChild) + equal1(tree-&gt;rightChild);
}
</code></pre><blockquote>
<p>计算节点度数为2的个数</p>
</blockquote>
<pre><code>int equal2(treePointer tree)            //计算节点度数为2的个数
{
    if (tree == NULL) {
        return 0;
    }
    if (tree -&gt; leftChild != NULL &amp;&amp; tree -&gt; rightChild)
        return equal2(tree -&gt; leftChild) + equal2(tree -&gt; rightChild) + 1;
    return equal2(tree -&gt; leftChild) + equal2(tree -&gt; rightChild);
}
</code></pre><blockquote>
<p>复制二叉树</p>
</blockquote>
<pre><code>treePointer copy(treePointer tree)
{
    treePointer newTree;
    if (tree == NULL) {
        return NULL;
    }
    else
    {
        newTree = (treePointer)malloc(sizeof(struct tree));
        newTree -&gt; data = tree -&gt; data;
        newTree -&gt; leftChild = copy(tree -&gt; leftChild);
        newTree -&gt; rightChild = copy(tree -&gt; rightChild);
    }
    return newTree;
}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/11/17/2015-11-17-Surge科学上网-iOS/" itemprop="url">
                  Surge科学上网
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-11-17T00:00:00+08:00" content="2015-11-17">
              2015-11-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>我也是靠这篇文章<a href="https://www.lifetyper.com/2015/10/shadowsocks_conf_for_surge_on_ios.html" target="_blank" rel="external">IOS翻墙神器Surge的ShadowSocks版本傻瓜配置文件</a>才得以实现，我现在只是把作者上面的文件放倒了我的网站上。</p>
<p>这里讲的是iOS的科学上网，首先iPhone要9.0以上的系统，要去App Store下个Surge，Surge只支持9.0以上的系统，要68块钱，具体怎么下么看自己咯，开发者还是个中国人，果然是受够了天朝的网络。希望这个不要轻易被封杀了。</p>
<p>还要个ss帐号，网上仔细找找有公开的，安不安全是另外一回事情了。</p>
<p><img src="http://cxray.github.io/public/images/Surge科学上网/IMG_4070.PNG" alt="图1"></p>
<p>1.首先点右上角的Edit，然后下面出现以下几行，点Download Configuration from URL</p>
<p><img src="http://cxray.github.io/public/images/Surge科学上网/IMG_4068.PNG" alt="图2"></p>
<p>2.输入以上，点OK</p>
<p><img src="http://cxray.github.io/public/images/Surge科学上网/IMG_4069.PNG" alt="图3"></p>
<p>3.在Edit in Text Mode中，改到自己的ss就好啦</p>
<p><img src="http://cxray.github.io/public/images/Surge科学上网/IMG_4071.PNG" alt="图4"></p>
<p>最后ins求关注啦，ray_cxl</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/11/01/2015-11-01-定位CoreLocation和MapKit-iOS/" itemprop="url">
                  定位CoreLocation和MapKit
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-11-01T00:00:00+08:00" content="2015-11-01">
              2015-11-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>使用CoreLocation需要在项目中先引入CoreLocation.framework，使用的类中代码引入CoreLocation</p>
<p>再info.plist表里面添加两个变量，NSLocationAlwaysUsageDescription和NSLocationWhenInUseUsageDescription，这两个ket的值将分别用于描述应用程序始终使用和使用期间使用定位的说明</p>
<p>通过定位服务管理类CLLocationManager来创建一个位置管理器，它能够给我们提供位置信息和高度信息，也可以监控设备进入或离开某个区域，还可以获得设备的运行方向</p>
<blockquote>
<p>初始化</p>
</blockquote>
<pre><code>let locationManager = CLLocationManager()
</code></pre><p>CLLocationManager属性和方法</p>
<ul>
<li>location 位置</li>
<li>desiredAccuracy  位置精度</li>
<li>func startUpdatingLocation()  开启更新位置</li>
<li>func stopUpdatingLocation()  停止更新位置</li>
<li>func startUpdatingHeading()  开启更新方向</li>
<li>func stopUpdatingLocation()  停止更新方向</li>
</ul>
<blockquote>
<p>设置代理，添加CLLocationManagerDelegate,viewDidLoad中</p>
</blockquote>
<pre><code>locationManager.delegate = self
</code></pre><blockquote>
<p>定位精度，viewDidLoad中</p>
</blockquote>
<pre><code>locationManager.desiredAccuracy =         kCLLocationAccuracyBest
</code></pre><ul>
<li>kCLLocationAccuracyBestForNavigation    精度最高，一般用于导航</li>
<li>kCLLocationAccuracyBest                 精确度最佳</li>
<li>kCLLocationAccuracyNearestTenMeters     精确度10m以内</li>
<li>kCLLocationAccuracyHundredMeters        精确度100m以内</li>
<li>kCLLocationAccuracyKilometer            精确度1000m以内</li>
<li>kCLLocationAccuracyThreeKilometers      精确度3000m以内</li>
</ul>
<p>对于位置管理器启动更新后，更新将不断传递给位置管理器委托，直到停止更新，我们无法直接控制位置管理器更新的频率，但可使用位置管理器的distanceFilter属性进行间接控制。在启动更新前设置属性distanceFilter，它指定设备（水平或垂直）移动多少米后才将另一个更新发送给委托。定位要求的精度越高，属性distanceFilter的值越小，应用程序的耗电量就越大。它的单位是米，我们也可以直接通过整形数字来设置这个距离，viewDidLoad中</p>
<pre><code>locationManager.distanceFilter = 200
</code></pre><blockquote>
<p>创建两个按钮，一个用于发出授权申请，设备会弹出提示，请求用户允许使用定位服务，另一个用于停止刷新定位服务</p>
</blockquote>
<pre><code> @IBAction func askForLocation(sender: AnyObject) {
    locationManager.requestAlwaysAuthorization()

}
@IBAction func stopUpdateLocation(sender: AnyObject) {
    locationManager.stopUpdatingLocation()
}
</code></pre><blockquote>
<p>通过didChangeAuthorizationStatus代理方法，可以获得设备是否运行使用定位服务</p>
</blockquote>
<ul>
<li>NotDetermined：用户还没有被请求获取授权</li>
<li>Restricted：用户在设置里关闭了位置服务</li>
<li>Denied：用户收到获取授权的请求，但点击了NO，或者在设置里关闭了</li>
<li>Authorized：用户收到获取授权的请求，点击了YES；（此状态在ios8废弃了，ios7以及以下可用）</li>
<li>AuthorizedAlways = kCLAuthorizationStatusAuthorized用户授权app在任何时候获取位置信息</li>
<li>AuthorizedWhenInUse：用户授权app在前台获取位置信息</li>
</ul>
<pre><code>func locationManager(manager: CLLocationManager, didChangeAuthorizationStatus status: CLAuthorizationStatus) {
     if status == CLAuthorizationStatus.AuthorizedAlways || status == CLAuthorizationStatus.AuthorizedWhenInUse
     {
         //允许使用定位

         //开始启动定位更新服务
         locationManager.startUpdatingLocation()
         print(&quot;定位开始&quot;)
     }
     else if status == CLAuthorizationStatus.Denied
     {
         print(&quot;请求被拒绝&quot;)
     }
     else if status == CLAuthorizationStatus.NotDetermined
     {
         print(&quot;用户还没有被请求获取授权&quot;)
     }
     else if status == CLAuthorizationStatus.Restricted
     {
         print(&quot;用户在设置里关闭了位置服务&quot;)
     }

}
</code></pre><p>定位改变时，委托会执行以下方法，可以得到新位置，旧位置，locations数组里会有前后位置的经度纬度坐标值，可以定义一个CLLocation坐标对象，来接收坐标值</p>
<p>CLLocation对象中包涵定位点的相关位置数据，主要有经度纬度，海拔信息，可以通过属性和方法来获取</p>
<ul>
<li>coordinate   位置的经度和纬度</li>
<li>altitude    位置的海拔</li>
<li>horizontalAccuracy  位置的水平精度</li>
<li>verticalAccuracy    位置的垂直精度</li>
<li>course  位置的方向</li>
<li>speed   位置的速度</li>
<li><p>func distanceFromLocation(location: CLLocation) -&gt; CLLocationDistance  两个位置之间的距离</p>
<pre><code>var currLocation :CLLocation!
@IBOutlet weak var longitudeTxt: UILabel!
@IBOutlet weak var latitudeTxt: UILabel!
@IBOutlet weak var heightTxt: UILabel!

func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    //获取最新坐标
    currLocation = locations.last
    //获取经度纬度海拔
    longitudeTxt.text = &quot;经度：\(currLocation.coordinate.longitude)&quot;
    latitudeTxt.text = &quot;纬度：\(currLocation.coordinate.latitude)&quot;
    heightTxt.text = &quot;高度：\(currLocation.altitude)&quot;
}

//两个坐标点的距离，这个方法只是为了说明func distanceFromLocation(location: CLLocation) -&gt; CLLocationDistance的使用
func distanceTo()
{
    var targetLocation = CLLocation(latitude: 53.203715, longitude: 50.160374)
    var distance = currLocation.distanceFromLocation(targetLocation)
    print(distance)
}
</code></pre></li>
</ul>
<p>使用以下方法可以获取设备移动的方向，参数newHeading是一个CLHeading对象，CLHeading通过一组属性来提供航向读数：magneticHeading和trueHeading。这些值的单位为度，类型为CLLocationDirection，即为双精度浮点数。trueHeading和magneticHeading分别表示真实航向和磁性航向，如果位置服务被关闭了，GPS和wifi就只能获取magneticHeading，只有打开位置服务，才能获取trueHeading（真实航向)如果航向为0.0，则前进方向为正北<br>航向为90.0，为东,航向为180.0，为南,航向为270.0，为西</p>
<p>CLHeading 类是显示位置方向的类，可以用于实现指南针功能，CLHeading常用的属性和方法如下</p>
<ul>
<li>magneticHeading  位置的磁极方向</li>
<li>trueHeading   位置的真实方向</li>
<li>headingAccuracy  方向的精度</li>
<li>timestamp  获取Core Location确定位置时的时间戳</li>
<li><p>description 获取方向数据</p>
<pre><code>@IBOutlet weak var trueHeading: UITextField!
@IBOutlet weak var magneticHeading: UITextField!
func locationManager(manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
    locationManager.startUpdatingLocation()
    trueHeading.text = &quot;\(newHeading.trueHeading)&quot;
    magneticHeading.text = &quot;\(newHeading.magneticHeading)&quot;
}
</code></pre></li>
</ul>
<blockquote>
<p>当定位出现错误时就会调用的委托方法如下</p>
</blockquote>
<pre><code>func locationManager(manager: CLLocationManager, didFailWithError error: NSError) {
    print(error)

    if let clErr = CLError(rawValue: error.code)
    {
        switch clErr{
        case .LocationUnknown:
            print(&quot;位置不明&quot;)
        case .Denied:
            print(&quot;允许检索位置被拒绝&quot;)
        case .Network:
            print(&quot;用于检索位置的网络不可用&quot;)
        default:
            print(&quot;未知的位置错误&quot;)
        }
    }
    else
    {
        print(&quot;其他错误&quot;)
        let alert = UIAlertView(title: &quot;提示信息&quot;, message: &quot;定位失败&quot;, delegate: nil, cancelButtonTitle: &quot;确定&quot;)
        alert.show()
    }
}
</code></pre><p>public enum CLError : Int </p>
<ul>
<li>case LocationUnknown // 位置目前未知。但CLLocation会继续努力获取</li>
<li>case Denied // 获取位置功能被拒绝使用</li>
<li>case Network // 一般情况下，网络相关错误</li>
<li>case HeadingFailure // 获取的位置标题信息，不能确定</li>
<li>case RegionMonitoringDenied // 位置区域已被用户监测</li>
<li>case RegionMonitoringFailure // 监测器不能注册</li>
<li>case RegionMonitoringSetupDelayed // 不能初始化检测器CL</li>
<li>case RegionMonitoringResponseDelayed // 区域监测响应延迟</li>
<li>case GeocodeFoundNoResult // 地理编码无结果</li>
<li>case GeocodeFoundPartialResult // 地理编码请求，得到部分结果</li>
<li>case GeocodeCanceled // 地理编码请求被取消</li>
<li>case DeferredFailed // 推迟模式失败</li>
<li>case DeferredNotUpdatingLocation // 由于位置更新失败或暂停，推迟模式失败</li>
<li>case DeferredAccuracyTooLow // 推迟模式不支持精度要求</li>
<li>case DeferredDistanceFiltered // 推迟模式无法支持距离滤波器</li>
<li>case DeferredCanceled // 推迟模式被取消</li>
<li>case RangingUnavailable // 无法进行测距</li>
<li>case RangingFailure // 通用测距故障</li>
</ul>
<blockquote>
<p>地理信息反编码</p>
</blockquote>
<p>通过CoreLocation类，得到的定位信息都是以经度和纬度表示的，一般都要把它反编码成一个地址，这就需要用到CLGeocoder类来实现地理信息反编码</p>
<pre><code>@IBAction func reverseGeocode(sender: AnyObject)
{
    let geocoder = CLGeocoder()
    var p: CLPlacemark?
    geocoder.reverseGeocodeLocation(currLocation, completionHandler: { (placemarks, error) -&gt; Void in
        //强制成中文
    let array = NSArray(object: &quot;zh-hans&quot;)
    NSUserDefaults.standardUserDefaults().setObject(array, forKey: &quot;AppleLanguages&quot;);

    //显示所有信息
    if error != nil
    {
        print(&quot;reverse geocode fail : \(error!.localizedDescription)&quot;)
        return
    }
    let pm = placemarks! as [CLPlacemark]
    if pm.count &gt; 0
    {
        p = placemarks![0] as CLPlacemark
        print(p)//输出反编码信息
    }
    else
    {
        print(&quot;No Placemarks&quot;)
    }
    })
}
</code></pre><blockquote>
<p>地理信息编码,同样可以根据一个地址来编码获取经度纬度</p>
</blockquote>
<pre><code>@IBAction func locationBianMa(sender: AnyObject) {
    //使用Google服务进行地理编码
    var geocoder = CLGeocoder()
    var p: CLPlacemark?
    geocoder.geocodeAddressString(&quot;北京海淀区北三环西路 39 号&quot;, completionHandler: { (placemarks,error) -&gt; Void in
        if error != nil{
            print(&quot;reverse geocode fail : \(error?.localizedDescription)&quot;)
            return
        }
        let pm = placemarks! as [CLPlacemark]
        if pm.count &gt; 0
        {
            p = placemarks![0] as CLPlacemark
            print(&quot;Longitude = \(p?.location?.coordinate.longitude)&quot;)
            print(&quot;Latitude = \(p?.location?.coordinate.latitude)&quot;)
            print(p)
        }
        else
        {
            print(&quot;No Placemarks&quot;)
        }
    })
}
</code></pre><p>#MapKit</p>
<p>MapKit框架主要提供了四个功能，显示地图，CLLocation和地址之间的转换，支持在地图上做标记 ，把一个位置解析成地址，需要导入MapKit.framework和import MapKit</p>
<blockquote>
<p>可以代码创建,这里用storyboard创建</p>
</blockquote>
<pre><code>//var mapView = MKMapView(frame: CGRectMake(0,0,320,200))
@IBOutlet weak var mainMapView: MKMapView!
</code></pre><p>地图显示的区域由region属性定义，如下<br>func setRegion(region: MKCoordinateRegion,animated: Bool)</p>
<p>MKCoordinateRegion类型结构如下</p>
<pre><code>struct MKCoordinateRegion {
        center :CLLocationCoordinate2D
        span :MKCoordinateSpan
    } 
</code></pre><p>MKCoordinateSpan结构也包含两个成员</p>
<pre><code>struct MKCoordinateSpan {
    var latitudeDelta: CLLocationDegrees   这个类型实际上也就是double类型
    var longitudeDelta: CLLocationDegrees
}
</code></pre><blockquote>
<p>创建一个获取位置的button</p>
</blockquote>
<pre><code>@IBAction func mapLocation(sender: AnyObject) {
    //MapKit
    //创建一个MKCoordinateSpan对象，设置地图的范围，越小越精确
    let latDelta = 0.05
    let longDelta = 0.05
    let currentLocationSpan = MKCoordinateSpanMake(latDelta, longDelta)

    //定义一个区域，坐标使用定位获取的当前坐标
    let currentRegion = MKCoordinateRegionMake((locationManager.location?.coordinate)!, currentLocationSpan)
    self.mainMapView.setRegion(currentRegion, animated: true)

    //通过mapType属性，可以设置地图的显示类型，比如标准地图模式，卫星模式，混合模式，具体代码如下
    //设置地图显示类型
    self.mainMapView.mapType = MKMapType.Satellite
    /*Standard标准地图，Satellite卫星，Hybrid混合地图，，SatelliteFlyover，HybridFlyover,Flyover城市观光的意思*/

    //可以在任何坐标位置添加大头针
    let objectAnnotation = MKPointAnnotation()
    //设置大头针显示位置，我们使用定位到的坐标
    objectAnnotation.coordinate = (locationManager.location?.coordinate)!
    //设置大头针之后显示的标题
    objectAnnotation.title = &quot;香港&quot;
    //设置点击大头针之后的显示的描述
    objectAnnotation.subtitle = &quot;一个好地方&quot;
    //添加大头针
    self.mainMapView.addAnnotation(objectAnnotation)

    //添加代理
    mainMapView.delegate = self
}
</code></pre><blockquote>
<p>代理的介绍</p>
</blockquote>
<pre><code>func mapView(mapView: MKMapView, regionWillChangeAnimated animated: Bool) {
    print(&quot;地图的缩放级别发生改变时&quot;)
}

func mapView(mapView: MKMapView, regionDidChangeAnimated animated: Bool) {
    print(&quot;地图的缩放完毕触发&quot;)
}

func mapViewWillStartLoadingMap(mapView: MKMapView) {
    print(&quot;开始加载地图&quot;)
}

func mapViewDidFinishLoadingMap(mapView: MKMapView) {
    print(&quot;结束加载地图&quot;)
}

func mapViewDidFailLoadingMap(mapView: MKMapView, withError error: NSError) {
    print(&quot;加载失败&quot;)
}

func mapViewWillStartRenderingMap(mapView: MKMapView) {
    print(&quot;开始渲染下载的地图块时调用&quot;)
}

func mapViewDidFinishRenderingMap(mapView: MKMapView, fullyRendered: Bool) {
    print(&quot;渲染下载的地图结束时调用&quot;)
}

//自定义大头针样式
func mapView(mapView: MKMapView, viewForAnnotation annotation: MKAnnotation) -&gt; MKAnnotationView? {
    if annotation is MKUserLocation
    {
        //return nil so map view draws &quot;blue dot&quot; for standard user location
        return nil
    }
    let reuseId = &quot;pin&quot;

    var pinView = mapView.dequeueReusableAnnotationViewWithIdentifier(reuseId) as? MKPinAnnotationView

    if pinView == nil
    {
        //创建一个大头针视图
        pinView = MKPinAnnotationView(annotation: annotation, reuseIdentifier: reuseId)
        pinView?.canShowCallout = true
        pinView?.animatesDrop = true

        //设置大头针颜色,这个以前只能用pinColor，现在可以使用其他颜色了
        pinView?.pinTintColor = UIColor.blackColor()

        //设置大头针点注释视图的右侧按钮样式
        pinView?.rightCalloutAccessoryView = UIButton(type: .DetailDisclosure)

    }
    else
    {
        pinView?.annotation = annotation
    }
    return pinView
}

func mapView(mapView: MKMapView, didAddAnnotationViews views: [MKAnnotationView]) {
    print(&quot;添加注释视图&quot;)
}

func mapView(mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {
    print(&quot;点击注释视图按钮&quot;)
}

func mapView(mapView: MKMapView, didSelectAnnotationView view: MKAnnotationView) {
    print(&quot;点击大头针注释视图&quot;)
}

func mapView(mapView: MKMapView, didDeselectAnnotationView view: MKAnnotationView) {
    print(&quot;取消点击大头针注释视图&quot;)
}

func mapViewWillStartLocatingUser(mapView: MKMapView) {
    print(&quot;正在跟踪用户的位置&quot;)
}

func mapViewDidStopLocatingUser(mapView: MKMapView) {
    print(&quot;停止跟踪用户的位置&quot;)
}

func mapView(mapView: MKMapView, didUpdateUserLocation userLocation: MKUserLocation) {
    print(&quot;更新用户的位置&quot;)
}

func mapView(mapView: MKMapView, didFailToLocateUserWithError error: NSError) {
    print(&quot;跟踪用户的位置失败&quot;)
}

func mapView(mapView: MKMapView, annotationView view: MKAnnotationView, didChangeDragState newState: MKAnnotationViewDragState, fromOldState oldState: MKAnnotationViewDragState) {
    //移动annotation位置时调用，newState为宏，表示几个状态，是否能移动位置在annotation中设置
    print(&quot;移动annotation位置时调用&quot;)
}

func mapView(mapView: MKMapView, didChangeUserTrackingMode mode: MKUserTrackingMode, animated: Bool) {
    print(&quot;改变UserTrackingMode&quot;)

    /*userTrackingMode：跟踪类型，是一个枚举：
    MKUserTrackingMode.None :不进行用户位置跟踪；
    MKUserTrackingMode.Follow :跟踪用户位置；
    MKUserTrackingMode.FollowWithHeading :跟踪用户位置并且跟踪用户前进方向；*/
}

func mapView(mapView: MKMapView, rendererForOverlay overlay: MKOverlay) -&gt; MKOverlayRenderer {
    //设置overlay的渲染
    let a = MKOverlayRenderer(overlay: overlay)
    return a
}

func mapView(mapView: MKMapView, didAddOverlayRenderers renderers: [MKOverlayRenderer]) {
    print(&quot;地图上加上了OverlayRenderers调用&quot;)
}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/10/29/2015-10-29-野心和梦想-瞎扯/" itemprop="url">
                  野心和梦想
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-10-29T00:00:00+08:00" content="2015-10-29">
              2015-10-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/瞎扯/" itemprop="url" rel="index">
                    <span itemprop="name">瞎扯</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>每天总有那么会间隔，空下来随便在网上看看，而我看了一会车，想到写篇文章谈谈自己的野心了。</p>
<p>人的野心总是巨大的，每个人都有着一颗不能估量的野心，总希望得到更好的。有些人为之奋斗了，而有些人则继续做梦。</p>
<p>网上充斥着鸡汤文，与现在这个浮躁的社会密不可分，很多人无意间读到了鸡汤文，心中泛起波涛，整个人充满了热血，可过了一会，热情褪去，只会想到，奋斗好累，休息一会吧，于是继续刷微博微信空间，直到又读到了一篇鸡汤文。</p>
<p>好像没有男人不爱跑车吧，妈的真的好贵，动辄一百多万，这还算便宜的。但是这引擎声和速度真的让人着迷，简直就是毒药啊！</p>
<p>真是羡慕富二代的，能在20多岁就能开得起这些跑车。也羡慕贾斯丁比伯，会唱歌，年纪轻轻靠自己买了辆豪车。</p>
<p>而我们的平凡，就从中考开始，注定走一条平凡人的路了。中考考上一所高中，高中浑浑噩噩三年或是奋斗三年，经历高考，有些人肉体翻墙到了国外，上大学，成为一个平凡人，而更大一部分，上大学，成为了一个更平凡的人。似乎我们每个人都是这么走，不敢有所妄想，乔布斯的辍学永远是特例。真不知道那些看了鸡汤文，学着乔布斯，比尔盖兹辍学的人怎么样了。</p>
<p>Ambition可以翻译成野心或是雄心，志向。野心，变个好听点的名字，就叫做梦想。梦想只不过是穿了件华丽衣裳的野心。人们更愿意接受穿衣裳的梦想，而不愿意接受赤裸的野心。</p>
<p>很喜欢中国合伙人中的一句话，当才华撑不起野心的时候，只能安静读书。中国合伙人这部片子充满了满满的鸡汤味，说得好像只要奋斗，就能成功一样。但的确，不奋斗，连成功的机会都没有。</p>
<p>能力撑不起自己心中的野心的时候，现在也许只是时间的问题，希望努力走下去，不在乎别人的目光，梦想和野心都需要静静地坚持。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/10/28/2015-10-28-加速计和陀螺仪-iOS/" itemprop="url">
                  加速计和陀螺仪
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-10-28T00:00:00+08:00" content="2015-10-28">
              2015-10-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>对于设备方向XYZ轴判断，iOS内置的对于设备朝向的判断，还有判断设备是否摇晃了</p>
<p>首先在storyboard中定义这几个label</p>
<pre><code>@IBOutlet weak var XLabel: UILabel!
@IBOutlet weak var YLabel: UILabel!
@IBOutlet weak var ZLabel: UILabel!
@IBOutlet weak var orientationLabel: UILabel!
@IBOutlet weak var shake: UILabel!
</code></pre><p>声明一个加速计管理者，所有的操作都会由这个motionManager接管</p>
<pre><code>var motionManager = CMMotionManager()
</code></pre><p>在viewDidLoad()中，添加   </p>
<pre><code>//设置检测时间
motionManager.accelerometerUpdateInterval = 0.1

//判断是否可以使用加速计
if motionManager.accelerometerAvailable
{
    //如果设备支持加速计，用startAccelermeterUpdatesToQueue方法开始检测设备的加速情况
    motionManager.startAccelerometerUpdatesToQueue(NSOperationQueue.mainQueue(), withHandler: 
    { ( accelerometerData :CMAccelerometerData?, error:NSError?) -&gt; Void in
        if error != nil
        {
            //停止使用加速计
            self.motionManager.stopAccelerometerUpdates()
        }
        else
        {
            self.XLabel.text = &quot;X:\(accelerometerData!.acceleration.x)&quot;
            self.YLabel.text = &quot;Y:\(accelerometerData!.acceleration.y)&quot;
            self.ZLabel.text = &quot;Z:\(accelerometerData!.acceleration.z)&quot;
        }
    })
}
else
{
    let alert = UIAlertView(title: &quot;你的设备不支持加速计&quot;, message: nil, delegate: nil, cancelButtonTitle: &quot;OK&quot;)
    alert.show()
}
</code></pre><p>用iOS内置的方法判断设备方向</p>
<pre><code>/*通过UIDevice.currentDevice()来获取设备，可以取得设备当前的方向，我们可以添加一个通知，来监听设备的方向变化，这样在开发中可以对不同的方向定制不同的排版布局界面，实现代码如下*/

//感知设备方向，开启监听设备方向
UIDevice.currentDevice().beginGeneratingDeviceOrientationNotifications()

//添加通知，监听设备方向改变
NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;receivedRotation&quot;, name: UIDeviceOrientationDidChangeNotification, object: nil)
</code></pre><p>如果要关闭设备监听，代码如下</p>
<pre><code>UIDevice.currentDevice().endGeneratingDeviceOrientationNotifications()
</code></pre><p>实现通知监听方法触发的代码</p>
<pre><code>func receivedRotation()
{
    let device = UIDevice.currentDevice()

    if device.orientation == UIDeviceOrientation.Unknown
    {
        orientationLabel.text = &quot;方向未知&quot;
    }
    else if device.orientation == UIDeviceOrientation.Portrait
    {
        orientationLabel.text = &quot;面向设备保持垂直，Home键位于下部&quot;
    }
    else if device.orientation == UIDeviceOrientation.PortraitUpsideDown
    {
        orientationLabel.text = &quot;面向设备保持垂直，Home键位于上部&quot;
    }
    else if device.orientation == UIDeviceOrientation.LandscapeLeft
    {
    　//但是这里我测试出来方向不一样，左和右反了
        orientationLabel.text = &quot;面向设备保持水平，Home键位于左侧&quot;
    }
    else if device.orientation == UIDeviceOrientation.LandscapeRight
    {
        orientationLabel.text = &quot;面向设备保持水平，Home键位于右侧&quot;
    }
    else if device.orientation == UIDeviceOrientation.FaceUp
    {
        orientationLabel.text = &quot;设备水平放，Home键朝上&quot;
    }
    else if device.orientation == UIDeviceOrientation.FaceDown
    {
        orientationLabel.text = &quot;设备水平放，Home键朝下&quot;
    }
}
</code></pre><p>摇晃，iOS SDK中已经将摇晃shake事件很方便的融合进去，就像触发touch事件一样简单，发生shake事件后程序会自动执行</p>
<pre><code>//开始摇晃
override func motionBegan(motion: UIEventSubtype, withEvent event: UIEvent?) {
    shake.text = &quot;开始摇晃&quot;
}
//摇晃结束
override func motionEnded(motion: UIEventSubtype, withEvent event: UIEvent?) {
    shake.text = &quot;摇晃结束&quot;
}
//摇晃被意外终止
override func motionCancelled(motion: UIEventSubtype, withEvent event: UIEvent?) {
    shake.text = &quot;摇晃被意外终止&quot;
}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/10/25/2015-10-25-手势识别-iOS/" itemprop="url">
                  手势识别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-10-25T00:00:00+08:00" content="2015-10-25">
              2015-10-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>手势识别GestureRecognizer绑定到view的对象，当发生手势时，绑定到的view对象会响应，它确定这个动作是否对应一个特定的手势，swipe，pinch，pan，rotation 如果能识别，那么它就会向绑定的view发送消息，每一个手势必须关联到对象中才会有作用，一个view对象可以关联多个手势，但每一个手势只能与一个view相关联，当用户触摸了这个view，这个GestureRecognizer就会接受到消息，响应特定的触摸事件</p>
<p>UITapGestureRecognizer 点击事件</p>
<p>UIPanGestureRecognizer 拖移，慢速移动</p>
<p>UILongPressGestureRecognizer  长按事件</p>
<p>UIPinchGestureRecognizer 捏合事件</p>
<p>UIRotationGestureRecognizer 旋转事件</p>
<p>UISwipeGestureRecognizer 轻扫事件，快速移动，分为上轻扫，下轻扫，左轻扫，右轻扫</p>
<p>通过代码创建，在storyboard中添加一个label</p>
<pre><code>@IBOutlet weak var label: UILabel!
</code></pre><blockquote>
<p>点击事件</p>
</blockquote>
<pre><code>let atap = UITapGestureRecognizer(target: self, action: &quot;tapDo:&quot;)
self.view.addGestureRecognizer(atap)
atap.numberOfTapsRequired = 1
</code></pre><blockquote>
<p>拖动事件</p>
</blockquote>
<pre><code>let aPan = UIPanGestureRecognizer(target: self, action: &quot;handlenPan:&quot;)
self.view.addGestureRecognizer(aPan)
//最少手指个数
aPan.minimumNumberOfTouches = 1
//最多手指个数
aPan.maximumNumberOfTouches = 3
</code></pre><blockquote>
<p>长按事件</p>
</blockquote>
<pre><code>let aLongPress = UILongPressGestureRecognizer(target: self, action: &quot;longPress:&quot;)
self.view.addGestureRecognizer(aLongPress)
//需要长按的时间，最少0.5s
aLongPress.minimumPressDuration = 1
</code></pre><blockquote>
<p>捏合事件</p>
</blockquote>
<pre><code>let aPinch = UIPinchGestureRecognizer(target: self, action: &quot;pinchDo:&quot;)
self.view.addGestureRecognizer(aPinch)
</code></pre><blockquote>
<p>旋转事件</p>
</blockquote>
<pre><code>let aRotation = UIRotationGestureRecognizer(target: self, action: &quot;rotatePiece:&quot;)
self.view.addGestureRecognizer(aRotation)
</code></pre><blockquote>
<p>轻扫事件，左轻扫</p>
</blockquote>
<pre><code>let leftSwipe = UISwipeGestureRecognizer(target: self, action: &quot;leftSwipe:&quot;)
self.view.addGestureRecognizer(leftSwipe)
leftSwipe.direction = UISwipeGestureRecognizerDirection.Left
</code></pre><blockquote>
<p>轻扫事件，右轻扫</p>
</blockquote>
<pre><code>let rigthSwipe = UISwipeGestureRecognizer(target: self, action: &quot;rightSwipe:&quot;)
self.view.addGestureRecognizer(rigthSwipe)
leftSwipe.direction = UISwipeGestureRecognizerDirection.Right
</code></pre><blockquote>
<p>轻扫事件，上轻扫</p>
</blockquote>
<pre><code>let upSwipe = UISwipeGestureRecognizer(target: self, action: &quot;upSwipe:&quot;)
self.view.addGestureRecognizer(upSwipe)
upSwipe.direction = UISwipeGestureRecognizerDirection.Up
</code></pre><blockquote>
<p>轻扫事件，下轻扫</p>
</blockquote>
<pre><code>let downSwipe = UISwipeGestureRecognizer(target: self, action: &quot;downSwipe:&quot;)
self.view.addGestureRecognizer(downSwipe)
downSwipe.direction = UISwipeGestureRecognizerDirection.Down
</code></pre><p>对应的各个函数</p>
<pre><code>func tapDo(sender: UITapGestureRecognizer)
{
    label.text = &quot;点击事件&quot;
}

func handlenPan(sender: UIPanGestureRecognizer)
{
    label.text = &quot;拖动事件&quot;
}

func longPress(sender: UILongPressGestureRecognizer)
{
    label.text = &quot;长按事件&quot;
}

func pinchDo(sender: UIPinchGestureRecognizer)
{
    label.text = &quot;捏合事件&quot;
}

func rotatePiece(sender: UIRotationGestureRecognizer)
{
    label.text = &quot;旋转事件&quot;
}

func leftSwipe(sender: UISwipeGestureRecognizer)
{
    label.text = &quot;左轻扫&quot;
}

func rightSwipe(sender: UISwipeGestureRecognizer)
{
    label.text = &quot;右轻扫&quot;
}

func upSwipe(sender: UISwipeGestureRecognizer)
{
    label.text = &quot;上轻扫&quot;
}

func downSwipe(sender: UISwipeGestureRecognizer)
{
    label.text = &quot;下轻扫&quot;
}
</code></pre><p>每个手势识别器一些常用的属性</p>
<p>点击事件</p>
<p>UITapGestureRecognizer</p>
<p>numberOfTouchesRequired 设置手指个数</p>
<p>numberOfTapsRequired 设置单击次数</p>
<p>拖动事件</p>
<p>UIPanGestureRecognizer</p>
<p>minimumNumberOfTouches 最少手指个数</p>
<p>maximumNumberOfTouches 最多手指个数</p>
<p>长按事件</p>
<p>UILongPressGestureRecognizer</p>
<p>minimumPressDuration 需要长按的时间，最小0.5s</p>
<p>numberOfTouchesRequired  需要长按的手指数</p>
<p>numberOfTapsRequired  需要长按的单击次数</p>
<p>allowableMovement 手指按住允许拖动的距离</p>
<p>捏合事件</p>
<p>UIPinchGestureRecognizer</p>
<p>scale 手指捏合，大于1时表示两个手指距离变大，小于1时两个手指距离变小<br>velocity 手指捏合时的速率</p>
<p>旋转事件</p>
<p>UIRotationGestureRecognizer</p>
<p>rotation 旋转方向，小于0为逆时针，大于0为顺时针</p>
<p>velocity 旋转速率</p>
<p>轻扫事件</p>
<p>UISwipeGestureRecognizer</p>
<p>numberOfTouchesRequired 轻扫手指的个数</p>
<p>direction  轻扫方向</p>
<p>获取手势识别器当前的状态</p>
<p>var state: UIGestureRecognizerState{ get }</p>
<p>枚举如下</p>
<pre><code>public enum UIGestureRecognizerState : Int {

case Possible // 默认状态，识别器还没有识别出当前状态    
case Began //触摸事件开始
case Changed // 触摸事件状态改变
case Ended //触摸事件结束
case Cancelled // 触摸事件意外终止，接电话时

case Failed // 识别器收到触摸，但不能识别手势

// Discrete Gestures – gesture recognizers that recognize a discrete event but do not report changes (for example, a tap) do not transition through the Began and Changed states and can not fail or be cancelled
public static var Recognized: UIGestureRecognizerState { get } // the recognizer has received touches recognized as the gesture. the action method will be called at the next turn of the run loop and the recognizer will be reset to UIGestureRecognizerStatePossible
}
</code></pre><p>拖动识别如下</p>
<pre><code>func handlenPan(sender: UIPanGestureRecognizer)
{
    label.text = &quot;拖动事件&quot;

    if sender.state == UIGestureRecognizerState.Began
    {
        print(&quot;拖动开始&quot;)
    }
    else if sender.state == UIGestureRecognizerState.Changed
    {
        print(&quot;拖动过程&quot;)
    }
    else if sender.state == UIGestureRecognizerState.Ended
    {
        print(&quot;拖动结束&quot;)
    }
}
</code></pre><p>获取相对于view的坐标，如下</p>
<p>func locationInView（view: UIView?） -&gt; CGPiont</p>
<pre><code>func tapDo(sender: UITapGestureRecognizer)
{
    label.text = &quot;点击事件&quot;
    print(sender.locationInView(self.view))
}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/headImage.JPG" alt="Ray" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Ray</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Live For The Dream!</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CXRay" target="_blank">
                  <i class="fa fa-github"></i> github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1795459455/" target="_blank">
                  <i class="fa fa-weibo"></i> weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.instagram.com/ray_oooooo/" target="_blank">
                  <i class="fa fa-instagram"></i> instagram
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
